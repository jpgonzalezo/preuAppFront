/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { HttpParams } from '@angular/common/http';
import { tdHttpRESTParam } from '../params/abstract-param.decorator';
import { of } from 'rxjs';
/** @type {?} */
export var NOOP_HTTP = of(undefined);
/**
 * Method used to copy parameters from an array or HttpParams object
 * into a centrilized HttpParams object
 * \@internal
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
export function parseParams(target, source) {
    /** @type {?} */
    var queryParams = target;
    if (source instanceof HttpParams) {
        source.keys().forEach(function (key) {
            // skip if value is undefined
            if (((/** @type {?} */ (source))).get(key) !== undefined) {
                queryParams = queryParams.set(key, ((/** @type {?} */ (source))).get(key));
            }
        });
    }
    else {
        for (var key in source) {
            // skip if value is undefined
            if ((/** @type {?} */ (source[key])) !== undefined) {
                queryParams = queryParams.set(key, (/** @type {?} */ (source[key])));
            }
        }
    }
    return queryParams;
}
/**
 * Abstract implementation of the http method decorator
 * \@internal
 * @param {?} config
 * @return {?}
 */
export function TdAbstractMethod(config) {
    return function (target, propertyName, descriptor) {
        /** @type {?} */
        var wrappedFunction = descriptor.value;
        // replace method call with our own and proxy it
        descriptor.value = function () {
            var e_1, _a, e_2, _b;
            try {
                /** @type {?} */
                var replacedPath = config.path;
                /** @type {?} */
                var parameters = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyName);
                /** @type {?} */
                var newArgs = [];
                /** @type {?} */
                var body = void 0;
                /** @type {?} */
                var queryParams = new HttpParams();
                if (parameters) {
                    try {
                        // map parameters and see which type they are to act on them
                        for (var parameters_1 = tslib_1.__values(parameters), parameters_1_1 = parameters_1.next(); !parameters_1_1.done; parameters_1_1 = parameters_1.next()) {
                            var parameter = parameters_1_1.value;
                            if (parameter.type === 'param') {
                                newArgs[parameter.index] = arguments[parameter.index];
                                replacedPath = replacedPath.replace(':' + parameter.param, arguments[parameter.index]);
                            }
                            else if (parameter.type === 'body') {
                                newArgs[parameter.index] = arguments[parameter.index];
                                body = arguments[parameter.index];
                            }
                            else if (parameter.type === 'queryParams') {
                                newArgs[parameter.index] = arguments[parameter.index];
                                /** @type {?} */
                                var qParams = arguments[parameter.index];
                                if (config.options && config.options.params) {
                                    queryParams = parseParams(queryParams, config.options.params);
                                }
                                if (qParams) {
                                    queryParams = parseParams(queryParams, qParams);
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (parameters_1_1 && !parameters_1_1.done && (_a = parameters_1.return)) _a.call(parameters_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                // tslint:disable-next-line
                /** @type {?} */
                var url = this.baseUrl + replacedPath;
                /** @type {?} */
                var options = Object.assign({}, config.options, {
                    body: body,
                    params: queryParams,
                });
                // tslint:disable-next-line
                /** @type {?} */
                var request = this.buildRequest(config.method, url, options);
                if (parameters) {
                    try {
                        // see which one was the response parameter so we can set the request observable
                        for (var parameters_2 = tslib_1.__values(parameters), parameters_2_1 = parameters_2.next(); !parameters_2_1.done; parameters_2_1 = parameters_2.next()) {
                            var parameter = parameters_2_1.value;
                            if (parameter.type === 'response') {
                                newArgs[parameter.index] = request;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (parameters_2_1 && !parameters_2_1.done && (_b = parameters_2.return)) _b.call(parameters_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                // tslint:disable-next-line
                /** @type {?} */
                var response = wrappedFunction.apply(this, newArgs);
                // if the response is NOOP_HTTP or undefined, then we return the request as it is
                // else we return the response from the inner function
                if (response === NOOP_HTTP || response === undefined) {
                    return request;
                }
                else {
                    return response;
                }
            }
            catch (error) {
                // tslint:disable-next-line
                console.error(error);
            }
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtbWV0aG9kLmRlY29yYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bjb3ZhbGVudC9odHRwLyIsInNvdXJjZXMiOlsiYWN0aW9ucy9tZXRob2RzL2Fic3RyYWN0LW1ldGhvZC5kZWNvcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFHbEQsT0FBTyxFQUFlLGVBQWUsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBRWxGLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBSXRDLE1BQU0sS0FBTyxTQUFTLEdBQW9CLEVBQUUsQ0FBQyxTQUFTLENBQUM7Ozs7Ozs7OztBQU92RCxNQUFNLFVBQVUsV0FBVyxDQUFDLE1BQWtCLEVBQUUsTUFBdUQ7O1FBQ2pHLFdBQVcsR0FBZSxNQUFNO0lBQ3BDLElBQUksTUFBTSxZQUFZLFVBQVUsRUFBRTtRQUNoQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLFVBQUMsR0FBVztZQUNoQyw2QkFBNkI7WUFDN0IsSUFBSSxDQUFDLG1CQUFZLE1BQU0sRUFBQSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFNBQVMsRUFBRTtnQkFDL0MsV0FBVyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsbUJBQVksTUFBTSxFQUFBLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNuRTtRQUNILENBQUMsQ0FBQyxDQUFDO0tBQ0o7U0FBTTtRQUNMLEtBQUssSUFBSSxHQUFHLElBQUksTUFBTSxFQUFFO1lBQ3RCLDZCQUE2QjtZQUM3QixJQUFJLG1CQUFLLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBQSxLQUFLLFNBQVMsRUFBRTtnQkFDbEMsV0FBVyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLG1CQUFLLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBQSxDQUFDLENBQUM7YUFDdEQ7U0FDRjtLQUNGO0lBQ0QsT0FBTyxXQUFXLENBQUM7QUFDckIsQ0FBQzs7Ozs7OztBQU1ELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxNQUloQztJQUNDLE9BQU8sVUFBVSxNQUFXLEVBQUUsWUFBb0IsRUFBRSxVQUE2Qzs7WUFDM0YsZUFBZSxHQUFhLFVBQVUsQ0FBQyxLQUFLO1FBQ2hELGdEQUFnRDtRQUNoRCxVQUFVLENBQUMsS0FBSyxHQUFHOztZQUNqQixJQUFJOztvQkFDRSxZQUFZLEdBQVcsTUFBTSxDQUFDLElBQUk7O29CQUNsQyxVQUFVLEdBQTBELE9BQU8sQ0FBQyxjQUFjLENBQUMsZUFBZSxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUM7O29CQUNqSSxPQUFPLEdBQVUsRUFBRTs7b0JBQ25CLElBQUksU0FBSzs7b0JBQ1QsV0FBVyxHQUFlLElBQUksVUFBVSxFQUFFO2dCQUM5QyxJQUFJLFVBQVUsRUFBRTs7d0JBQ2QsNERBQTREO3dCQUM1RCxLQUFzQixJQUFBLGVBQUEsaUJBQUEsVUFBVSxDQUFBLHNDQUFBLDhEQUFFOzRCQUE3QixJQUFJLFNBQVMsdUJBQUE7NEJBQ2hCLElBQUksU0FBUyxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUU7Z0NBQzlCLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQ0FDdEQsWUFBWSxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzZCQUN4RjtpQ0FBTSxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO2dDQUNwQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Z0NBQ3RELElBQUksR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDOzZCQUNuQztpQ0FBTSxJQUFJLFNBQVMsQ0FBQyxJQUFJLEtBQUssYUFBYSxFQUFFO2dDQUMzQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7O29DQUNsRCxPQUFPLEdBQW9ELFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO2dDQUN6RixJQUFJLE1BQU0sQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7b0NBQzNDLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7aUNBQy9EO2dDQUNELElBQUksT0FBTyxFQUFFO29DQUNYLFdBQVcsR0FBRyxXQUFXLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2lDQUNqRDs2QkFDRjt5QkFDRjs7Ozs7Ozs7O2lCQUNGOzs7b0JBRUcsR0FBRyxHQUFXLElBQUksQ0FBQyxPQUFPLEdBQUcsWUFBWTs7b0JBQ3pDLE9BQU8sR0FBK0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRTtvQkFDMUUsSUFBSSxFQUFFLElBQUk7b0JBQ1YsTUFBTSxFQUFFLFdBQVc7aUJBQ3BCLENBQUM7OztvQkFFRSxPQUFPLEdBQVEsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUM7Z0JBQ2pFLElBQUksVUFBVSxFQUFFOzt3QkFDZCxnRkFBZ0Y7d0JBQ2hGLEtBQXNCLElBQUEsZUFBQSxpQkFBQSxVQUFVLENBQUEsc0NBQUEsOERBQUU7NEJBQTdCLElBQUksU0FBUyx1QkFBQTs0QkFDaEIsSUFBSSxTQUFTLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtnQ0FDakMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUM7NkJBQ3BDO3lCQUNGOzs7Ozs7Ozs7aUJBQ0Y7OztvQkFFRyxRQUFRLEdBQVEsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDO2dCQUN4RCxpRkFBaUY7Z0JBQ2pGLHNEQUFzRDtnQkFDdEQsSUFBSSxRQUFRLEtBQUssU0FBUyxJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7b0JBQ3BELE9BQU8sT0FBTyxDQUFDO2lCQUNoQjtxQkFBTTtvQkFDTCxPQUFPLFFBQVEsQ0FBQztpQkFDakI7YUFDRjtZQUFDLE9BQU8sS0FBSyxFQUFFO2dCQUNkLDJCQUEyQjtnQkFDM0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN0QjtRQUNILENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwUGFyYW1zIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuXG5pbXBvcnQgeyBUZEh0dHBNZXRob2QsIElUZEh0dHBSRVNUT3B0aW9ucywgSVRkSHR0cFJFU1RPcHRpb25zV2l0aEJvZHkgfSBmcm9tICcuLi8uLi9odHRwLmludGVyZmFjZXMnO1xuaW1wb3J0IHsgVGRQYXJhbVR5cGUsIHRkSHR0cFJFU1RQYXJhbSB9IGZyb20gJy4uL3BhcmFtcy9hYnN0cmFjdC1wYXJhbS5kZWNvcmF0b3InO1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuXG5kZWNsYXJlIGNvbnN0IFJlZmxlY3Q6IGFueTtcblxuZXhwb3J0IGNvbnN0IE5PT1BfSFRUUDogT2JzZXJ2YWJsZTxhbnk+ID0gb2YodW5kZWZpbmVkKTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byBjb3B5IHBhcmFtZXRlcnMgZnJvbSBhbiBhcnJheSBvciBIdHRwUGFyYW1zIG9iamVjdFxuICogaW50byBhIGNlbnRyaWxpemVkIEh0dHBQYXJhbXMgb2JqZWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW1zKHRhcmdldDogSHR0cFBhcmFtcywgc291cmNlOiBIdHRwUGFyYW1zIHwge1trZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdfSk6IEh0dHBQYXJhbXMge1xuICBsZXQgcXVlcnlQYXJhbXM6IEh0dHBQYXJhbXMgPSB0YXJnZXQ7XG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBIdHRwUGFyYW1zKSB7XG4gICAgc291cmNlLmtleXMoKS5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgLy8gc2tpcCBpZiB2YWx1ZSBpcyB1bmRlZmluZWRcbiAgICAgIGlmICgoPEh0dHBQYXJhbXM+c291cmNlKS5nZXQoa2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXMuc2V0KGtleSwgKDxIdHRwUGFyYW1zPnNvdXJjZSkuZ2V0KGtleSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIC8vIHNraXAgaWYgdmFsdWUgaXMgdW5kZWZpbmVkXG4gICAgICBpZiAoPGFueT5zb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXMuc2V0KGtleSwgPGFueT5zb3VyY2Vba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBxdWVyeVBhcmFtcztcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgaHR0cCBtZXRob2QgZGVjb3JhdG9yXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRkQWJzdHJhY3RNZXRob2QoY29uZmlnOiB7XG4gIG1ldGhvZDogVGRIdHRwTWV0aG9kLFxuICBwYXRoOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBJVGRIdHRwUkVTVE9wdGlvbnMsXG59KTogRnVuY3Rpb24ge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBwcm9wZXJ0eU5hbWU6IHN0cmluZywgZGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8RnVuY3Rpb24+KTogYW55IHtcbiAgICBsZXQgd3JhcHBlZEZ1bmN0aW9uOiBGdW5jdGlvbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgLy8gcmVwbGFjZSBtZXRob2QgY2FsbCB3aXRoIG91ciBvd24gYW5kIHByb3h5IGl0XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpOiBhbnkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlcGxhY2VkUGF0aDogc3RyaW5nID0gY29uZmlnLnBhdGg7XG4gICAgICAgIGxldCBwYXJhbWV0ZXJzOiB7IGluZGV4OiBudW1iZXIsIHBhcmFtOiBzdHJpbmcsIHR5cGU6IFRkUGFyYW1UeXBlIH1bXSA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEodGRIdHRwUkVTVFBhcmFtLCB0YXJnZXQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGxldCBuZXdBcmdzOiBhbnlbXSA9IFtdO1xuICAgICAgICBsZXQgYm9keTogYW55O1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXM6IEh0dHBQYXJhbXMgPSBuZXcgSHR0cFBhcmFtcygpO1xuICAgICAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgICAgIC8vIG1hcCBwYXJhbWV0ZXJzIGFuZCBzZWUgd2hpY2ggdHlwZSB0aGV5IGFyZSB0byBhY3Qgb24gdGhlbVxuICAgICAgICAgIGZvciAobGV0IHBhcmFtZXRlciBvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdwYXJhbScpIHtcbiAgICAgICAgICAgICAgbmV3QXJnc1twYXJhbWV0ZXIuaW5kZXhdID0gYXJndW1lbnRzW3BhcmFtZXRlci5pbmRleF07XG4gICAgICAgICAgICAgIHJlcGxhY2VkUGF0aCA9IHJlcGxhY2VkUGF0aC5yZXBsYWNlKCc6JyArIHBhcmFtZXRlci5wYXJhbSwgYXJndW1lbnRzW3BhcmFtZXRlci5pbmRleF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgIG5ld0FyZ3NbcGFyYW1ldGVyLmluZGV4XSA9IGFyZ3VtZW50c1twYXJhbWV0ZXIuaW5kZXhdO1xuICAgICAgICAgICAgICBib2R5ID0gYXJndW1lbnRzW3BhcmFtZXRlci5pbmRleF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlci50eXBlID09PSAncXVlcnlQYXJhbXMnKSB7XG4gICAgICAgICAgICAgIG5ld0FyZ3NbcGFyYW1ldGVyLmluZGV4XSA9IGFyZ3VtZW50c1twYXJhbWV0ZXIuaW5kZXhdO1xuICAgICAgICAgICAgICBsZXQgcVBhcmFtczogSHR0cFBhcmFtcyB8IHtba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXX0gPSBhcmd1bWVudHNbcGFyYW1ldGVyLmluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gcGFyc2VQYXJhbXMocXVlcnlQYXJhbXMsIGNvbmZpZy5vcHRpb25zLnBhcmFtcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHFQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcyA9IHBhcnNlUGFyYW1zKHF1ZXJ5UGFyYW1zLCBxUGFyYW1zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgbGV0IHVybDogc3RyaW5nID0gdGhpcy5iYXNlVXJsICsgcmVwbGFjZWRQYXRoO1xuICAgICAgICBsZXQgb3B0aW9uczogSVRkSHR0cFJFU1RPcHRpb25zV2l0aEJvZHkgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcub3B0aW9ucywge1xuICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgcGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBsZXQgcmVxdWVzdDogYW55ID0gdGhpcy5idWlsZFJlcXVlc3QoY29uZmlnLm1ldGhvZCwgdXJsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAvLyBzZWUgd2hpY2ggb25lIHdhcyB0aGUgcmVzcG9uc2UgcGFyYW1ldGVyIHNvIHdlIGNhbiBzZXQgdGhlIHJlcXVlc3Qgb2JzZXJ2YWJsZVxuICAgICAgICAgIGZvciAobGV0IHBhcmFtZXRlciBvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdyZXNwb25zZScpIHtcbiAgICAgICAgICAgICAgbmV3QXJnc1twYXJhbWV0ZXIuaW5kZXhdID0gcmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGxldCByZXNwb25zZTogYW55ID0gd3JhcHBlZEZ1bmN0aW9uLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAvLyBpZiB0aGUgcmVzcG9uc2UgaXMgTk9PUF9IVFRQIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSByZXR1cm4gdGhlIHJlcXVlc3QgYXMgaXQgaXNcbiAgICAgICAgLy8gZWxzZSB3ZSByZXR1cm4gdGhlIHJlc3BvbnNlIGZyb20gdGhlIGlubmVyIGZ1bmN0aW9uXG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gTk9PUF9IVFRQIHx8IHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuIl19