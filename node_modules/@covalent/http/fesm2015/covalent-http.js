import { Injectable, Injector, ɵReflectionCapabilities, Optional, SkipSelf, Self, Inject, inject, INJECTOR, NgModule, InjectionToken, defineInjectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { HttpClient, HttpHeaders, HttpClientModule, HttpHandler, HttpParams } from '@angular/common/http';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class TdInterceptorBehaviorService {
    /**
     * @param {?} _injector
     * @param {?} _httpInterceptorMatcher
     * @param {?} requestInterceptorConfigs
     */
    constructor(_injector, _httpInterceptorMatcher, requestInterceptorConfigs) {
        this._injector = _injector;
        this._httpInterceptorMatcher = _httpInterceptorMatcher;
        this._requestInterceptors = [];
        requestInterceptorConfigs.forEach((config) => {
            this._requestInterceptors.push({
                interceptor: (/** @type {?} */ (_injector.get(config.interceptor))),
                paths: config.paths,
            });
        });
    }
    /**
     * @return {?}
     */
    get requestInterceptors() {
        return this._requestInterceptors;
    }
    /**
     * @return {?}
     */
    get httpInterceptorMatcher() {
        return this._httpInterceptorMatcher;
    }
}
class TdHttpService extends HttpClient {
    /**
     * @param {?} _handler
     * @param {?} _interceptorBehavior
     */
    constructor(_handler, _interceptorBehavior) {
        super(_handler);
        this._handler = _handler;
        this._interceptorBehavior = _interceptorBehavior;
    }
    /**
     * @param {?} first
     * @param {?=} url
     * @param {?=} options
     * @return {?}
     */
    request(first, url, options = {}) {
        /** @type {?} */
        let interceptors = this._interceptorBehavior.requestInterceptors.filter((mapping) => {
            return this._interceptorBehavior.httpInterceptorMatcher.matches({ url: url }, mapping);
        }).map((mapping) => {
            return mapping.interceptor;
        });
        return this._setupRequest(first, url, options, interceptors);
    }
    /**
     * @param {?} method
     * @param {?} url
     * @param {?} options
     * @param {?} interceptors
     * @return {?}
     */
    _setupRequest(method, url, options, interceptors) {
        try {
            options = this._requestResolve(options, interceptors);
        }
        catch (e) {
            return new Observable((subscriber) => {
                subscriber.error(e);
            });
        }
        return this._handleResponseResolve(super.request((/** @type {?} */ (method)), url, options), interceptors);
    }
    /**
     * @param {?} options
     * @param {?} interceptors
     * @return {?}
     */
    _requestResolve(options, interceptors) {
        interceptors.forEach((interceptor) => {
            if (interceptor.handleOptions) {
                options = interceptor.handleOptions(options);
            }
        });
        return options;
    }
    /**
     * @param {?} obs
     * @param {?} interceptors
     * @return {?}
     */
    _handleResponseResolve(obs, interceptors) {
        interceptors.reverse().forEach((interceptor) => {
            if (interceptor.handleResponse) {
                obs = interceptor.handleResponse(obs);
            }
        });
        return obs;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * DO NOT MODIFY
 * Taken from angular since they dont expose this function
 * This is used internally to inject services from the constructor of the base service using the mixinHttp
 * \@internal
 * @param {?} types
 * @param {?} injector
 * @return {?}
 */
function injectArgs(types, injector) {
    /** @type {?} */
    const args = [];
    for (let i = 0; i < types.length; i++) {
        /** @type {?} */
        const arg = types[i];
        if (arg) {
            if (Array.isArray(arg)) {
                if (arg.length === 0) {
                    throw new Error('Arguments array must have arguments.');
                }
                /** @type {?} */
                let type = undefined;
                /** @type {?} */
                let flags = 0 /* Default */;
                for (let j = 0; j < arg.length; j++) {
                    /** @type {?} */
                    const meta = arg[j];
                    if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {
                        /* tslint:disable */
                        flags |= 8 /* Optional */;
                    }
                    else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {
                        flags |= 4 /* SkipSelf */;
                    }
                    else if (meta instanceof Self || meta.ngMetadataName === 'Self') {
                        flags |= 2 /* Self */;
                    }
                    else if (meta instanceof Inject) {
                        type = meta.token;
                    }
                    else {
                        type = meta;
                    }
                    /* tslint:enable */
                }
                args.push(injector.get((/** @type {?} */ (type)), flags));
            }
            else {
                args.push(injector.get(arg));
            }
        }
    }
    return args;
}
/**
 * @return {?}
 */
function getInjector() {
    try {
        return inject(INJECTOR);
    }
    catch (e) {
        if (!InternalHttpService._injector) {
            throw new Error('Please add CovalentHttpModule into your imports.');
        }
        return InternalHttpService._injector;
    }
}
/**
 * Mixin to augment a service with http helpers.
 * \@internal
 * @param {?} base
 * @param {?} config
 * @param {?=} httpInject
 * @return {?}
 */
function mixinHttp(base, config, httpInject = TdHttpService) {
    /**
     * Internal class used to get an instance of Injector for internal usage plus also
     * a way to inject services from the constructor of the underlying service
     * \@internal
     * @abstract
     */
    class HttpInternalClass extends base {
        /**
         * @param {...?} args
         */
        constructor(...args) {
            super(...(args && args.length ? args : injectArgs(new ɵReflectionCapabilities().parameters(base), getInjector())));
            this._injector = getInjector();
            this.buildConfig();
        }
    }
    /**
     * Actuall class being returned with all the hooks for http usage
     * @internal
     */
    return class extends HttpInternalClass {
        /**
         * @return {?}
         */
        get baseUrl() {
            return (typeof (this.basePath) === 'string' ?
                this.basePath.replace(/\/$/, '') : '') + this._baseUrl;
        }
        /**
         * Method used to setup the configuration parameters and get an instance of the http service
         * @return {?}
         */
        buildConfig() {
            this.http = this._injector.get(httpInject);
            this._baseUrl = config && config.baseUrl ? config.baseUrl.replace(/\/$/, '') : '';
            this._baseHeaders = config && config.baseHeaders ? config.baseHeaders : new HttpHeaders();
            this._defaultObserve = config && config.defaultObserve ? config.defaultObserve : 'body';
            this._defaultResponseType = config && config.defaultResponseType ? config.defaultResponseType : 'json';
        }
        /**
         * Method used to build the default headers using the base headers
         * @return {?}
         */
        buildHeaders() {
            /** @type {?} */
            let headersObj = {};
            this._baseHeaders.keys().forEach((key) => {
                headersObj[key] = this._baseHeaders.get(key);
            });
            return new HttpHeaders(headersObj);
        }
        /* tslint:disable-next-line */
        /**
         * @template HttpResponse
         * @param {?} method
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        buildRequest(method, url, options) {
            return this._buildRequest(method, url, options);
        }
        /**
         * Method used to build the request depending on the `http` service and TdHttpMethod
         * @param {?} method
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        _buildRequest(method, url, options = {}) {
            if (!options.responseType) {
                options.responseType = this._defaultResponseType;
            }
            if (!options.observe) {
                options.observe = this._defaultObserve;
            }
            if (!options.headers) {
                options.headers = this.buildHeaders();
            }
            else {
                /** @type {?} */
                let headers = this.buildHeaders();
                if (options.headers instanceof HttpHeaders) {
                    ((/** @type {?} */ (options.headers))).keys().forEach((key) => {
                        headers = headers.set(key, ((/** @type {?} */ (options.headers))).get(key));
                    });
                }
                else {
                    for (let key in options.headers) {
                        headers = headers.set(key, (/** @type {?} */ (options.headers[key])));
                    }
                }
                options.headers = headers;
            }
            return ((/** @type {?} */ (this.http))).request(method, url, options);
        }
    };
}
/**
 * \@internal
 * WORKAROUND until Ivy Renderer is ready
 */
class InternalHttpService {
    /**
     * @param {?} _injector
     */
    constructor(_injector) {
        InternalHttpService._injector = _injector;
    }
}
InternalHttpService._injector = undefined;
InternalHttpService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
InternalHttpService.ctorParameters = () => [
    { type: Injector }
];
/** @nocollapse */ InternalHttpService.ngInjectableDef = defineInjectable({ factory: function InternalHttpService_Factory() { return new InternalHttpService(inject(INJECTOR)); }, token: InternalHttpService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Concrete implementation for http interceptor matchers.
 * This implementation uses regex to check mapping paths vs request url.
 */
class TdURLRegExpInterceptorMatcher {
    /**
     * @param {?} options
     * @param {?} mapping
     * @return {?}
     */
    matches(options, mapping) {
        return mapping.paths.filter((path) => {
            path = path.replace(/\*\*/gi, '<>')
                .replace(/\*/gi, '[a-zA-Z0-9\\-_]+')
                .replace(/<>/gi, '[a-zA-Z0-9\\-_\/]*');
            if (path) {
                path += '(\\?{1}.*)?$';
                return new RegExp(path).test(options.url);
            }
            return false;
        }).length > 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const HTTP_CONFIG = new InjectionToken('HTTP_CONFIG');
/**
 * @param {?} handler
 * @param {?} injector
 * @param {?} config
 * @return {?}
 */
function httpFactory(handler, injector, config) {
    return new TdHttpService(handler, new TdInterceptorBehaviorService(injector, new TdURLRegExpInterceptorMatcher(), config.interceptors));
}
/** @type {?} */
const HTTP_INTERCEPTOR_PROVIDER = {
    provide: TdHttpService,
    useFactory: httpFactory,
    deps: [HttpHandler, Injector, HTTP_CONFIG],
};
class CovalentHttpModule {
    /**
     * @param {?} _internalHttpService
     */
    constructor(_internalHttpService) {
        this._internalHttpService = _internalHttpService;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = { interceptors: [] }) {
        return {
            ngModule: CovalentHttpModule,
            providers: [{
                    provide: HTTP_CONFIG,
                    useValue: config,
                },
                HTTP_INTERCEPTOR_PROVIDER,
            ],
        };
    }
}
CovalentHttpModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule,
                ],
                providers: [
                    InternalHttpService,
                ],
            },] }
];
/** @nocollapse */
CovalentHttpModule.ctorParameters = () => [
    { type: InternalHttpService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const tdHttpRESTParam = Symbol('TdHttpRESTParam');
/**
 * Abstract implementation of the http param decorator
 * \@internal
 * @param {?} type
 * @param {?=} param
 * @return {?}
 */
function TdAbstractParam(type, param) {
    return function (target, propertyKey, parameterIndex) {
        /** @type {?} */
        let parameters = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyKey) || [];
        parameters.push({
            index: parameterIndex,
            param: param,
            type: type,
        });
        Reflect.defineMetadata(tdHttpRESTParam, parameters, target, propertyKey);
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const NOOP_HTTP = of(undefined);
/**
 * Method used to copy parameters from an array or HttpParams object
 * into a centrilized HttpParams object
 * \@internal
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function parseParams(target, source) {
    /** @type {?} */
    let queryParams = target;
    if (source instanceof HttpParams) {
        source.keys().forEach((key) => {
            // skip if value is undefined
            if (((/** @type {?} */ (source))).get(key) !== undefined) {
                queryParams = queryParams.set(key, ((/** @type {?} */ (source))).get(key));
            }
        });
    }
    else {
        for (let key in source) {
            // skip if value is undefined
            if ((/** @type {?} */ (source[key])) !== undefined) {
                queryParams = queryParams.set(key, (/** @type {?} */ (source[key])));
            }
        }
    }
    return queryParams;
}
/**
 * Abstract implementation of the http method decorator
 * \@internal
 * @param {?} config
 * @return {?}
 */
function TdAbstractMethod(config) {
    return function (target, propertyName, descriptor) {
        /** @type {?} */
        let wrappedFunction = descriptor.value;
        // replace method call with our own and proxy it
        descriptor.value = function () {
            try {
                /** @type {?} */
                let replacedPath = config.path;
                /** @type {?} */
                let parameters = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyName);
                /** @type {?} */
                let newArgs = [];
                /** @type {?} */
                let body;
                /** @type {?} */
                let queryParams = new HttpParams();
                if (parameters) {
                    // map parameters and see which type they are to act on them
                    for (let parameter of parameters) {
                        if (parameter.type === 'param') {
                            newArgs[parameter.index] = arguments[parameter.index];
                            replacedPath = replacedPath.replace(':' + parameter.param, arguments[parameter.index]);
                        }
                        else if (parameter.type === 'body') {
                            newArgs[parameter.index] = arguments[parameter.index];
                            body = arguments[parameter.index];
                        }
                        else if (parameter.type === 'queryParams') {
                            newArgs[parameter.index] = arguments[parameter.index];
                            /** @type {?} */
                            let qParams = arguments[parameter.index];
                            if (config.options && config.options.params) {
                                queryParams = parseParams(queryParams, config.options.params);
                            }
                            if (qParams) {
                                queryParams = parseParams(queryParams, qParams);
                            }
                        }
                    }
                }
                // tslint:disable-next-line
                /** @type {?} */
                let url = this.baseUrl + replacedPath;
                /** @type {?} */
                let options = Object.assign({}, config.options, {
                    body: body,
                    params: queryParams,
                });
                // tslint:disable-next-line
                /** @type {?} */
                let request = this.buildRequest(config.method, url, options);
                if (parameters) {
                    // see which one was the response parameter so we can set the request observable
                    for (let parameter of parameters) {
                        if (parameter.type === 'response') {
                            newArgs[parameter.index] = request;
                        }
                    }
                }
                // tslint:disable-next-line
                /** @type {?} */
                let response = wrappedFunction.apply(this, newArgs);
                // if the response is NOOP_HTTP or undefined, then we return the request as it is
                // else we return the response from the inner function
                if (response === NOOP_HTTP || response === undefined) {
                    return request;
                }
                else {
                    return response;
                }
            }
            catch (error) {
                // tslint:disable-next-line
                console.error(error);
            }
        };
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that adds GET request capabilities to a method
 * @param {?} config
 * @return {?}
 */
function TdGET(config) {
    return TdAbstractMethod((/** @type {?} */ (Object.assign({
        method: 'GET',
    }, config))));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that adds POST request capabilities to a method
 * @param {?} config
 * @return {?}
 */
function TdPOST(config) {
    return TdAbstractMethod((/** @type {?} */ (Object.assign({
        method: 'POST',
    }, config))));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that adds PATCH request capabilities to a method
 * @param {?} config
 * @return {?}
 */
function TdPATCH(config) {
    return TdAbstractMethod((/** @type {?} */ (Object.assign({
        method: 'PATCH',
    }, config))));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that adds PUT request capabilities to a method
 * @param {?} config
 * @return {?}
 */
function TdPUT(config) {
    return TdAbstractMethod((/** @type {?} */ (Object.assign({
        method: 'PUT',
    }, config))));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that adds DELETE request capabilities to a method
 * @param {?} config
 * @return {?}
 */
function TdDELETE(config) {
    return TdAbstractMethod((/** @type {?} */ (Object.assign({
        method: 'DELETE',
    }, config))));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator used to give a service http capabilities using TdHttpService
 * @param {?} config
 * @return {?}
 */
function TdHttp(config) {
    return function (constructor) {
        return class extends mixinHttp(constructor, config, TdHttpService) {
        };
    };
}
/**
 * Decorator used to give a service http capabilities using HttpClient
 * @param {?} config
 * @return {?}
 */
function TdHttpClient(config) {
    return function (constructor) {
        return class extends mixinHttp(constructor, config, HttpClient) {
        };
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that is used to define which parameter is an http parameter in a method
 * @param {?} param
 * @return {?}
 */
function TdParam(param) {
    return TdAbstractParam('param', param);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that is used to define which parameter is the http body in a method
 * @return {?}
 */
function TdBody() {
    return TdAbstractParam('body');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that is used to define which parameter is the http response in a method
 * @return {?}
 */
function TdResponse() {
    return TdAbstractParam('response');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Decorator that is used to define which parameter is the http query parameters in a method
 * @return {?}
 */
function TdQueryParams() {
    return TdAbstractParam('queryParams');
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { TdHttpService, httpFactory, HTTP_CONFIG, HTTP_INTERCEPTOR_PROVIDER, CovalentHttpModule, TdURLRegExpInterceptorMatcher, TdGET, TdPOST, TdPATCH, TdPUT, TdDELETE, TdHttp, TdHttpClient, TdParam, TdBody, TdResponse, TdQueryParams, getInjector, mixinHttp, InternalHttpService, InternalHttpService as ɵb, TdInterceptorBehaviorService as ɵa };

//# sourceMappingURL=covalent-http.js.map