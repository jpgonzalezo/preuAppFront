{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@covalent/http/interceptors/http.service.ts","ng://@covalent/http/actions/http.mixin.ts","ng://@covalent/http/interceptors/url-regexp-interceptor-matcher.class.ts","ng://@covalent/http/http.module.ts","ng://@covalent/http/actions/params/abstract-param.decorator.ts","ng://@covalent/http/actions/methods/abstract-method.decorator.ts","ng://@covalent/http/actions/methods/get.decorator.ts","ng://@covalent/http/actions/methods/post.decorator.ts","ng://@covalent/http/actions/methods/patch.decorator.ts","ng://@covalent/http/actions/methods/put.decorator.ts","ng://@covalent/http/actions/methods/delete.decorator.ts","ng://@covalent/http/actions/class/http.decorator.ts","ng://@covalent/http/actions/params/param.decorator.ts","ng://@covalent/http/actions/params/body.decorator.ts","ng://@covalent/http/actions/params/response.decorator.ts","ng://@covalent/http/actions/params/query-params.decorator.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__values","o","m","Symbol","iterator","i","call","next","length","value","done","__read","n","r","e","ar","push","error","TdInterceptorBehaviorService","_injector","_httpInterceptorMatcher","requestInterceptorConfigs","_this","_requestInterceptors","forEach","config","interceptor","get","paths","defineProperty","TdHttpService","_handler","_interceptorBehavior","_super","tslib_1.__extends","request","first","url","options","interceptors","requestInterceptors","filter","mapping","httpInterceptorMatcher","matches","map","_setupRequest","method","_requestResolve","Observable","subscriber","_handleResponseResolve","handleOptions","obs","reverse","handleResponse","HttpClient","getInjector","inject","INJECTOR","InternalHttpService","Error","mixinHttp","base","httpInject","class_1","basePath","replace","_baseUrl","buildConfig","http","baseUrl","_baseHeaders","baseHeaders","HttpHeaders","_defaultObserve","defaultObserve","_defaultResponseType","defaultResponseType","buildHeaders","headersObj","keys","key","buildRequest","_buildRequest","responseType","observe","headers","headers_1","set","HttpInternalClass","args","_i","arguments","apply","__spread","concat","injectArgs","types","injector","arg","isArray","type","undefined","flags","j","meta","Optional","ngMetadataName","SkipSelf","Self","Inject","token","ɵReflectionCapabilities","parameters","Injectable","providedIn","Injector","TdURLRegExpInterceptorMatcher","path","RegExp","test","HTTP_CONFIG","InjectionToken","httpFactory","handler","HTTP_INTERCEPTOR_PROVIDER","provide","useFactory","deps","HttpHandler","CovalentHttpModule","_internalHttpService","forRoot","ngModule","providers","useValue","NgModule","imports","HttpClientModule","tdHttpRESTParam","TdAbstractParam","param","target","propertyKey","parameterIndex","Reflect","getOwnMetadata","index","defineMetadata","NOOP_HTTP","of","parseParams","source","queryParams","HttpParams","TdAbstractMethod","propertyName","descriptor","wrappedFunction","replacedPath","newArgs","body","parameters_1","tslib_1.__values","parameters_1_1","parameter","qParams","params","assign","parameters_2","parameters_2_1","response","console","TdGET","TdPOST","TdPATCH","TdPUT","TdDELETE","TdHttp","TdHttpClient","class_2","TdParam","TdBody","TdResponse","TdQueryParams"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Type, Injector } from '@angular/core';\nimport { HttpClient, HttpHandler, HttpResponse, HttpRequest, HttpHeaders, HttpParams } from '@angular/common/http';\n\nimport { Observable, Subscriber } from 'rxjs';\n\nimport { ITdHttpInterceptor } from './http-interceptor.interface';\nimport { ITdHttpInterceptorMatcher } from './http-interceptor-matcher.interface';\nimport { ITdHttpInterceptorMapping } from './http-interceptor-mapping.interface';\n\nimport { ITdHttpRESTOptionsWithBody } from '../http.interfaces';\n\nexport interface ITdHttpInterceptorConfig {\n  interceptor: Type<any>;\n  paths: string[];\n}\n\nexport class TdInterceptorBehaviorService {\n  private _requestInterceptors: ITdHttpInterceptorMapping[] = [];\n\n  get requestInterceptors(): ITdHttpInterceptorMapping[] {\n    return this._requestInterceptors;\n  }\n\n  get httpInterceptorMatcher(): ITdHttpInterceptorMatcher {\n    return this._httpInterceptorMatcher;\n  }\n\n  constructor(private _injector: Injector,\n              private _httpInterceptorMatcher: ITdHttpInterceptorMatcher,\n              requestInterceptorConfigs: ITdHttpInterceptorConfig[]) {\n    requestInterceptorConfigs.forEach((config: ITdHttpInterceptorConfig) => {\n      this._requestInterceptors.push({\n        interceptor: <ITdHttpInterceptor>_injector.get(config.interceptor),\n        paths: config.paths,\n      });\n    });\n  }\n}\n\nexport class TdHttpService extends HttpClient {\n\n  constructor(private _handler: HttpHandler,\n              private _interceptorBehavior: TdInterceptorBehaviorService) {\n    super(_handler);\n  }\n\n  request(first: string|HttpRequest<any>, url?: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body' | 'events' | 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    let interceptors: ITdHttpInterceptor[] = this._interceptorBehavior.requestInterceptors.filter((mapping: ITdHttpInterceptorMapping) => {\n      return this._interceptorBehavior.httpInterceptorMatcher.matches({url: url}, mapping);\n    }).map((mapping: ITdHttpInterceptorMapping) => {\n      return mapping.interceptor;\n    });\n    return this._setupRequest(first, url, options, interceptors);\n  }\n\n  private _setupRequest(method: string|HttpRequest<any>,\n                        url: string,\n                        options: ITdHttpRESTOptionsWithBody,\n                        interceptors: ITdHttpInterceptor[]): Observable<HttpResponse<any>> {\n    try {\n      options = this._requestResolve(options, interceptors);\n    } catch (e) {\n      return new Observable<any>((subscriber: Subscriber<any>) => {\n        subscriber.error(e);\n      });\n    }\n    return this._handleResponseResolve(super.request(<any>method, url, options), interceptors);\n  }\n\n  private _requestResolve(options: ITdHttpRESTOptionsWithBody, interceptors: ITdHttpInterceptor[]): ITdHttpRESTOptionsWithBody {\n    interceptors.forEach((interceptor: ITdHttpInterceptor) => {\n      if (interceptor.handleOptions) {\n        options = interceptor.handleOptions(options);\n      }\n    });\n    return options;\n  }\n\n  private _handleResponseResolve(obs: Observable<any>, interceptors: ITdHttpInterceptor[]): Observable<any> {\n    interceptors.reverse().forEach((interceptor: ITdHttpInterceptor) => {\n      if (interceptor.handleResponse) {\n        obs = interceptor.handleResponse(obs);\n      }\n    });\n    return obs;\n  }\n}\n","import { Type, Injectable, Injector, ÉµReflectionCapabilities, InjectFlags, Optional,\n  SkipSelf, Self, Inject, InjectionToken, inject, INJECTOR } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { TdHttpService } from '../interceptors/http.service';\n\nimport { Observable } from 'rxjs';\n\nimport { ITdHttpRESTOptions, ITdHttpRESTOptionsWithBody, TdHttpRESTResponseType, TdHttpRESTObserve, TdHttpMethod } from '../http.interfaces';\n\nexport interface ITdHttpRESTConfig {\n  baseHeaders?: HttpHeaders;\n  baseUrl: string;\n  defaultObserve?: TdHttpRESTObserve;\n  defaultResponseType?: TdHttpRESTResponseType;\n}\n\ntype Constructor<T> = new (...args: any[]) => T;\n\n/**\n * DO NOT MODIFY\n * Taken from angular since they dont expose this function\n * This is used internally to inject services from the constructor of the base service using the mixinHttp\n * @internal\n */\nfunction injectArgs(types: (Type<any>| InjectionToken<any>| any[])[], injector: Injector): any[] {\n  const args: any[] = [];\n  for (let i: number = 0; i < types.length; i++) {\n    const arg: any = types[i];\n    if (arg) {\n      if (Array.isArray(arg)) {\n        if (arg.length === 0) {\n          throw new Error('Arguments array must have arguments.');\n        }\n        let type: Type<any>|undefined = undefined;\n        let flags: InjectFlags = InjectFlags.Default;\n\n        for (let j: number = 0; j < arg.length; j++) {\n          const meta: any = arg[j];\n          if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n            /* tslint:disable */\n            flags |= InjectFlags.Optional;\n          } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n            flags |= InjectFlags.SkipSelf;\n          } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n            flags |= InjectFlags.Self;\n          } else if (meta instanceof Inject) {\n            type = meta.token;\n          } else {\n            type = meta;\n          }\n          /* tslint:enable */\n        }\n\n        args.push(injector.get(type !, flags));\n      } else {\n        args.push(injector.get(arg));\n      }\n    }\n  }\n  return args;\n}\n\nexport function getInjector(): Injector {\n  try {\n    return inject(INJECTOR);\n  } catch (e) {\n    if (!InternalHttpService._injector) {\n      throw new Error('Please add CovalentHttpModule into your imports.');\n    }\n    return InternalHttpService._injector;\n  }\n}\n\n/** \n * Mixin to augment a service with http helpers.\n * @internal\n */\nexport function mixinHttp(base: any,\n                          config: ITdHttpRESTConfig,\n                          httpInject: Type<HttpClient | TdHttpService> = TdHttpService): Constructor<any> {\n  /**\n   * Internal class used to get an instance of Injector for internal usage plus also\n   * a way to inject services from the constructor of the underlying service\n   * @internal\n   */\n  abstract class HttpInternalClass extends base {\n    constructor(...args: any[]) {\n      super(...(args && args.length ? args : injectArgs(new ÉµReflectionCapabilities().parameters(base), getInjector())));\n      this._injector = getInjector();\n      this.buildConfig();\n    }\n    abstract buildConfig(): void;\n  }\n  /**\n   * Actuall class being returned with all the hooks for http usage\n   * @internal\n   */\n  return class extends HttpInternalClass {\n    private _baseUrl: string;\n    get baseUrl(): string {\n      return (typeof(this.basePath) === 'string' ?\n        this.basePath.replace(/\\/$/, '') : '') + this._baseUrl;\n    }\n    private _baseHeaders: HttpHeaders;\n    private _defaultObserve?: TdHttpRESTObserve;\n    private _defaultResponseType?: TdHttpRESTResponseType;\n\n    http: HttpClient | TdHttpService;\n\n    /**\n     * Method used to setup the configuration parameters and get an instance of the http service\n     */\n    buildConfig(): void {\n      this.http = this._injector.get(httpInject);\n      this._baseUrl = config && config.baseUrl ? config.baseUrl.replace(/\\/$/, '') : '';\n      this._baseHeaders = config && config.baseHeaders ? config.baseHeaders : new HttpHeaders();\n      this._defaultObserve = config && config.defaultObserve ? config.defaultObserve : 'body';\n      this._defaultResponseType = config && config.defaultResponseType ? config.defaultResponseType : 'json';\n    }\n\n    /**\n     * Method used to build the default headers using the base headers\n     */\n    buildHeaders(): HttpHeaders {\n      let headersObj: {[key: string]: any} = {};\n      this._baseHeaders.keys().forEach((key: any) => {\n        headersObj[key] = this._baseHeaders.get(key);\n      });\n      return new HttpHeaders(headersObj);\n    }\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: 'POST' | 'PUT' | 'PATCH', url: string, options?: ITdHttpRESTOptionsWithBody): Observable<HttpResponse>;\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: 'GET' | 'DELETE', url: string, options?: ITdHttpRESTOptions): Observable<HttpResponse>;\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: TdHttpMethod, url: string, options?: ITdHttpRESTOptionsWithBody): Observable<HttpResponse> {\n      return this._buildRequest(method, url, options);\n    }\n\n    /**\n     * Method used to build the request depending on the `http` service and TdHttpMethod\n     */\n    private _buildRequest(method: TdHttpMethod, url: string, options: ITdHttpRESTOptionsWithBody = {}): Observable<any> {\n      if (!options.responseType) {\n        options.responseType = this._defaultResponseType;\n      }\n      if (!options.observe) {\n        options.observe = this._defaultObserve;\n      }\n      if (!options.headers) {\n        options.headers = this.buildHeaders();\n      } else {\n        let headers: HttpHeaders = this.buildHeaders();\n        if (options.headers instanceof HttpHeaders) {\n          (<HttpHeaders>options.headers).keys().forEach((key: any) => {\n            headers = headers.set(key, (<HttpHeaders>options.headers).get(key));\n          });\n        } else {\n          for (let key in options.headers) {\n            headers = headers.set(key, <any>options.headers[key]);\n          }\n        }\n        options.headers = headers;\n      }\n      return (<TdHttpService>this.http).request(method, url, options);\n    }\n  };\n}\n\n/** \n * @internal\n * WORKAROUND until Ivy Renderer is ready\n */\n@Injectable({providedIn: 'root'})\nexport class InternalHttpService {\n\n  static _injector: Injector = undefined;\n\n  constructor(_injector: Injector) {\n    InternalHttpService._injector = _injector;\n  }\n}\n","import { ITdHttpInterceptorMapping } from './http-interceptor-mapping.interface';\nimport { ITdHttpInterceptorMatcher } from './http-interceptor-matcher.interface';\n\n/**\n * Concrete implementation for http interceptor matchers.\n * This implementation uses regex to check mapping paths vs request url.\n */\nexport class TdURLRegExpInterceptorMatcher implements ITdHttpInterceptorMatcher {\n\n  matches(options: {url: string}, mapping: ITdHttpInterceptorMapping): boolean {\n    return mapping.paths.filter((path: string) => {\n      path = path.replace(/\\*\\*/gi, '<>')\n                .replace(/\\*/gi, '[a-zA-Z0-9\\\\-_]+')\n                .replace(/<>/gi, '[a-zA-Z0-9\\\\-_\\/]*');\n      if (path) {\n        path += '(\\\\?{1}.*)?$';\n        return new RegExp(path).test(options.url);\n      }\n      return false;\n    }).length > 0;\n  }\n\n}\n","import { NgModule, ModuleWithProviders, Injector, InjectionToken, Provider } from '@angular/core';\nimport { HttpClientModule, HttpHandler } from '@angular/common/http';\n\nimport { InternalHttpService } from './actions/http.mixin';\n\nimport { TdHttpService, TdInterceptorBehaviorService, ITdHttpInterceptorConfig } from './interceptors/http.service';\nimport { TdURLRegExpInterceptorMatcher } from './interceptors/url-regexp-interceptor-matcher.class';\n\nexport const HTTP_CONFIG: InjectionToken<HttpConfig> = new InjectionToken<HttpConfig>('HTTP_CONFIG');\n\nexport type HttpConfig = {interceptors: ITdHttpInterceptorConfig[]};\n\nexport function httpFactory(handler: HttpHandler, injector: Injector, config: HttpConfig): TdHttpService {\n  return new TdHttpService(\n              handler,\n              new TdInterceptorBehaviorService(injector, new TdURLRegExpInterceptorMatcher(), config.interceptors),\n            );\n}\n\nexport const HTTP_INTERCEPTOR_PROVIDER: Provider = {\n  provide: TdHttpService,\n  useFactory: httpFactory,\n  deps: [HttpHandler, Injector, HTTP_CONFIG],\n};\n\n@NgModule({\n  imports: [\n    HttpClientModule,\n  ],\n  providers: [\n    InternalHttpService,\n  ],\n})\nexport class CovalentHttpModule {\n\n  constructor(private _internalHttpService: InternalHttpService) {}\n\n  static forRoot(config: HttpConfig = {interceptors: []}): ModuleWithProviders {\n    return {\n      ngModule: CovalentHttpModule,\n      providers: [{\n          provide: HTTP_CONFIG,\n          useValue: config,\n        },\n        HTTP_INTERCEPTOR_PROVIDER,\n      ],\n    };\n  }\n}\n","declare const Reflect: any;\nexport type TdParamType = 'param' | 'response' | 'body' | 'queryParams';\n\nexport const tdHttpRESTParam: Symbol = Symbol('TdHttpRESTParam');\n\n/**\n * Abstract implementation of the http param decorator\n * @internal\n */\nexport function TdAbstractParam(type: TdParamType, param?: string): Function {\n  return function (target: Object, propertyKey: string | symbol, parameterIndex: number): void {\n    let parameters: { index: number, param: string, type: TdParamType }[] = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyKey) || [];\n    parameters.push({\n      index: parameterIndex,\n      param: param,\n      type: type,\n    });\n    Reflect.defineMetadata(tdHttpRESTParam, parameters, target, propertyKey);\n  };\n}\n","import { HttpParams } from '@angular/common/http';\n\nimport { TdHttpMethod, ITdHttpRESTOptions, ITdHttpRESTOptionsWithBody } from '../../http.interfaces';\nimport { TdParamType, tdHttpRESTParam } from '../params/abstract-param.decorator';\n\nimport { Observable, of } from 'rxjs';\n\ndeclare const Reflect: any;\n\nexport const NOOP_HTTP: Observable<any> = of(undefined);\n\n/**\n * Method used to copy parameters from an array or HttpParams object\n * into a centrilized HttpParams object\n * @internal\n */\nexport function parseParams(target: HttpParams, source: HttpParams | {[key: string]: string | string[]}): HttpParams {\n  let queryParams: HttpParams = target;\n  if (source instanceof HttpParams) {\n    source.keys().forEach((key: string) => {\n      // skip if value is undefined\n      if ((<HttpParams>source).get(key) !== undefined) {\n        queryParams = queryParams.set(key, (<HttpParams>source).get(key));\n      }\n    });\n  } else {\n    for (let key in source) {\n      // skip if value is undefined\n      if (<any>source[key] !== undefined) {\n        queryParams = queryParams.set(key, <any>source[key]);\n      }\n    }\n  }\n  return queryParams;\n}\n\n/**\n * Abstract implementation of the http method decorator\n * @internal\n */\nexport function TdAbstractMethod(config: {\n  method: TdHttpMethod,\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>): any {\n    let wrappedFunction: Function = descriptor.value;\n    // replace method call with our own and proxy it\n    descriptor.value = function (): any {\n      try {\n        let replacedPath: string = config.path;\n        let parameters: { index: number, param: string, type: TdParamType }[] = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyName);\n        let newArgs: any[] = [];\n        let body: any;\n        let queryParams: HttpParams = new HttpParams();\n        if (parameters) {\n          // map parameters and see which type they are to act on them\n          for (let parameter of parameters) {\n            if (parameter.type === 'param') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              replacedPath = replacedPath.replace(':' + parameter.param, arguments[parameter.index]);\n            } else if (parameter.type === 'body') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              body = arguments[parameter.index];\n            } else if (parameter.type === 'queryParams') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              let qParams: HttpParams | {[key: string]: string | string[]} = arguments[parameter.index];\n              if (config.options && config.options.params) {\n                queryParams = parseParams(queryParams, config.options.params);\n              }\n              if (qParams) {\n                queryParams = parseParams(queryParams, qParams);\n              }\n            }\n          }\n        }\n        // tslint:disable-next-line\n        let url: string = this.baseUrl + replacedPath;\n        let options: ITdHttpRESTOptionsWithBody = Object.assign({}, config.options, {\n          body: body,\n          params: queryParams,\n        });\n        // tslint:disable-next-line\n        let request: any = this.buildRequest(config.method, url, options);\n        if (parameters) {\n          // see which one was the response parameter so we can set the request observable\n          for (let parameter of parameters) {\n            if (parameter.type === 'response') {\n              newArgs[parameter.index] = request;\n            }\n          }\n        }\n        // tslint:disable-next-line\n        let response: any = wrappedFunction.apply(this, newArgs);\n        // if the response is NOOP_HTTP or undefined, then we return the request as it is\n        // else we return the response from the inner function\n        if (response === NOOP_HTTP || response === undefined) {\n          return request;\n        } else {\n          return response;\n        }\n      } catch (error) {\n        // tslint:disable-next-line\n        console.error(error);\n      }\n    };\n  };\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds GET request capabilities to a method\n */\nexport function TdGET(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'GET',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds POST request capabilities to a method\n */\nexport function TdPOST(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'POST',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds PATCH request capabilities to a method\n */\nexport function TdPATCH(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'PATCH',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds PUT request capabilities to a method\n */\nexport function TdPUT(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'PUT',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds DELETE request capabilities to a method\n */\nexport function TdDELETE(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'DELETE',\n  }, config));\n}\n","import { HttpClient } from '@angular/common/http';\n\nimport { mixinHttp, ITdHttpRESTConfig } from '../http.mixin';\n\nimport { TdHttpService } from '../../interceptors/http.service';\n\n/**\n * Decorator used to give a service http capabilities using TdHttpService\n */\nexport function TdHttp(config: ITdHttpRESTConfig): Function {\n  return function <T extends { new(...args: any[]): {} }>(constructor: any): any {\n    return class extends mixinHttp(constructor, config, TdHttpService) {\n     \n    };\n  };\n}\n\n/**\n * Decorator used to give a service http capabilities using HttpClient\n */\nexport function TdHttpClient(config: ITdHttpRESTConfig): Function {\n  return function <T extends { new(...args: any[]): {} }>(constructor: any): any {\n    return class extends mixinHttp(constructor, config, HttpClient) {\n     \n    };\n  };\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is an http parameter in a method\n */\nexport function TdParam(param: string): Function {\n  return TdAbstractParam('param', param);\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http body in a method\n */\nexport function TdBody(): Function {\n  return TdAbstractParam('body');\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http response in a method\n */\nexport function TdResponse(): Function {\n  return TdAbstractParam('response');\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http query parameters in a method\n */\nexport function TdQueryParams(): Function {\n  return TdAbstractParam('queryParams');\n}\n"]}