(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('@covalent/http', ['exports', '@angular/core', 'rxjs', '@angular/common/http'], factory) :
    (factory((global.covalent = global.covalent || {}, global.covalent.http = {}),global.ng.core,global.rxjs,global.ng.common.http));
}(this, (function (exports,i0,rxjs,http) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var TdInterceptorBehaviorService = /** @class */ (function () {
        function TdInterceptorBehaviorService(_injector, _httpInterceptorMatcher, requestInterceptorConfigs) {
            var _this = this;
            this._injector = _injector;
            this._httpInterceptorMatcher = _httpInterceptorMatcher;
            this._requestInterceptors = [];
            requestInterceptorConfigs.forEach(function (config) {
                _this._requestInterceptors.push({
                    interceptor: ( /** @type {?} */(_injector.get(config.interceptor))),
                    paths: config.paths,
                });
            });
        }
        Object.defineProperty(TdInterceptorBehaviorService.prototype, "requestInterceptors", {
            get: /**
             * @return {?}
             */ function () {
                return this._requestInterceptors;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TdInterceptorBehaviorService.prototype, "httpInterceptorMatcher", {
            get: /**
             * @return {?}
             */ function () {
                return this._httpInterceptorMatcher;
            },
            enumerable: true,
            configurable: true
        });
        return TdInterceptorBehaviorService;
    }());
    var TdHttpService = /** @class */ (function (_super) {
        __extends(TdHttpService, _super);
        function TdHttpService(_handler, _interceptorBehavior) {
            var _this = _super.call(this, _handler) || this;
            _this._handler = _handler;
            _this._interceptorBehavior = _interceptorBehavior;
            return _this;
        }
        /**
         * @param {?} first
         * @param {?=} url
         * @param {?=} options
         * @return {?}
         */
        TdHttpService.prototype.request = /**
         * @param {?} first
         * @param {?=} url
         * @param {?=} options
         * @return {?}
         */
            function (first, url, options) {
                var _this = this;
                if (options === void 0) {
                    options = {};
                }
                /** @type {?} */
                var interceptors = this._interceptorBehavior.requestInterceptors.filter(function (mapping) {
                    return _this._interceptorBehavior.httpInterceptorMatcher.matches({ url: url }, mapping);
                }).map(function (mapping) {
                    return mapping.interceptor;
                });
                return this._setupRequest(first, url, options, interceptors);
            };
        /**
         * @param {?} method
         * @param {?} url
         * @param {?} options
         * @param {?} interceptors
         * @return {?}
         */
        TdHttpService.prototype._setupRequest = /**
         * @param {?} method
         * @param {?} url
         * @param {?} options
         * @param {?} interceptors
         * @return {?}
         */
            function (method, url, options, interceptors) {
                try {
                    options = this._requestResolve(options, interceptors);
                }
                catch (e) {
                    return new rxjs.Observable(function (subscriber) {
                        subscriber.error(e);
                    });
                }
                return this._handleResponseResolve(_super.prototype.request.call(this, ( /** @type {?} */(method)), url, options), interceptors);
            };
        /**
         * @param {?} options
         * @param {?} interceptors
         * @return {?}
         */
        TdHttpService.prototype._requestResolve = /**
         * @param {?} options
         * @param {?} interceptors
         * @return {?}
         */
            function (options, interceptors) {
                interceptors.forEach(function (interceptor) {
                    if (interceptor.handleOptions) {
                        options = interceptor.handleOptions(options);
                    }
                });
                return options;
            };
        /**
         * @param {?} obs
         * @param {?} interceptors
         * @return {?}
         */
        TdHttpService.prototype._handleResponseResolve = /**
         * @param {?} obs
         * @param {?} interceptors
         * @return {?}
         */
            function (obs, interceptors) {
                interceptors.reverse().forEach(function (interceptor) {
                    if (interceptor.handleResponse) {
                        obs = interceptor.handleResponse(obs);
                    }
                });
                return obs;
            };
        return TdHttpService;
    }(http.HttpClient));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * DO NOT MODIFY
     * Taken from angular since they dont expose this function
     * This is used internally to inject services from the constructor of the base service using the mixinHttp
     * \@internal
     * @param {?} types
     * @param {?} injector
     * @return {?}
     */
    function injectArgs(types, injector) {
        /** @type {?} */
        var args = [];
        for (var i = 0; i < types.length; i++) {
            /** @type {?} */
            var arg = types[i];
            if (arg) {
                if (Array.isArray(arg)) {
                    if (arg.length === 0) {
                        throw new Error('Arguments array must have arguments.');
                    }
                    /** @type {?} */
                    var type = undefined;
                    /** @type {?} */
                    var flags = 0 /* Default */;
                    for (var j = 0; j < arg.length; j++) {
                        /** @type {?} */
                        var meta = arg[j];
                        if (meta instanceof i0.Optional || meta.ngMetadataName === 'Optional') {
                            /* tslint:disable */
                            flags |= 8 /* Optional */;
                        }
                        else if (meta instanceof i0.SkipSelf || meta.ngMetadataName === 'SkipSelf') {
                            flags |= 4 /* SkipSelf */;
                        }
                        else if (meta instanceof i0.Self || meta.ngMetadataName === 'Self') {
                            flags |= 2 /* Self */;
                        }
                        else if (meta instanceof i0.Inject) {
                            type = meta.token;
                        }
                        else {
                            type = meta;
                        }
                        /* tslint:enable */
                    }
                    args.push(injector.get(( /** @type {?} */(type)), flags));
                }
                else {
                    args.push(injector.get(arg));
                }
            }
        }
        return args;
    }
    /**
     * @return {?}
     */
    function getInjector() {
        try {
            return i0.inject(i0.INJECTOR);
        }
        catch (e) {
            if (!InternalHttpService._injector) {
                throw new Error('Please add CovalentHttpModule into your imports.');
            }
            return InternalHttpService._injector;
        }
    }
    /**
     * Mixin to augment a service with http helpers.
     * \@internal
     * @param {?} base
     * @param {?} config
     * @param {?=} httpInject
     * @return {?}
     */
    function mixinHttp(base, config, httpInject) {
        if (httpInject === void 0) {
            httpInject = TdHttpService;
        }
        /**
         * Internal class used to get an instance of Injector for internal usage plus also
         * a way to inject services from the constructor of the underlying service
         * \@internal
         * @abstract
         */
        var /**
         * Internal class used to get an instance of Injector for internal usage plus also
         * a way to inject services from the constructor of the underlying service
         * \@internal
         * @abstract
         */ HttpInternalClass = /** @class */ (function (_super) {
            __extends(HttpInternalClass, _super);
            function HttpInternalClass() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spread((args && args.length ? args : injectArgs(new i0.ɵReflectionCapabilities().parameters(base), getInjector())))) || this;
                _this._injector = getInjector();
                _this.buildConfig();
                return _this;
            }
            return HttpInternalClass;
        }(base));
        /**
         * Actuall class being returned with all the hooks for http usage
         * @internal
         */
        return /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(class_1.prototype, "baseUrl", {
                get: /**
                 * @return {?}
                 */ function () {
                    return (typeof (this.basePath) === 'string' ?
                        this.basePath.replace(/\/$/, '') : '') + this._baseUrl;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Method used to setup the configuration parameters and get an instance of the http service
             */
            /**
             * Method used to setup the configuration parameters and get an instance of the http service
             * @return {?}
             */
            class_1.prototype.buildConfig = /**
             * Method used to setup the configuration parameters and get an instance of the http service
             * @return {?}
             */
                function () {
                    this.http = this._injector.get(httpInject);
                    this._baseUrl = config && config.baseUrl ? config.baseUrl.replace(/\/$/, '') : '';
                    this._baseHeaders = config && config.baseHeaders ? config.baseHeaders : new http.HttpHeaders();
                    this._defaultObserve = config && config.defaultObserve ? config.defaultObserve : 'body';
                    this._defaultResponseType = config && config.defaultResponseType ? config.defaultResponseType : 'json';
                };
            /**
             * Method used to build the default headers using the base headers
             */
            /**
             * Method used to build the default headers using the base headers
             * @return {?}
             */
            class_1.prototype.buildHeaders = /**
             * Method used to build the default headers using the base headers
             * @return {?}
             */
                function () {
                    var _this = this;
                    /** @type {?} */
                    var headersObj = {};
                    this._baseHeaders.keys().forEach(function (key) {
                        headersObj[key] = _this._baseHeaders.get(key);
                    });
                    return new http.HttpHeaders(headersObj);
                };
            /* tslint:disable-next-line */
            /* tslint:disable-next-line */
            /**
             * @template HttpResponse
             * @param {?} method
             * @param {?} url
             * @param {?=} options
             * @return {?}
             */
            class_1.prototype.buildRequest = /* tslint:disable-next-line */
                /**
                 * @template HttpResponse
                 * @param {?} method
                 * @param {?} url
                 * @param {?=} options
                 * @return {?}
                 */
                function (method, url, options) {
                    return this._buildRequest(method, url, options);
                };
            /**
             * Method used to build the request depending on the `http` service and TdHttpMethod
             */
            /**
             * Method used to build the request depending on the `http` service and TdHttpMethod
             * @param {?} method
             * @param {?} url
             * @param {?=} options
             * @return {?}
             */
            class_1.prototype._buildRequest = /**
             * Method used to build the request depending on the `http` service and TdHttpMethod
             * @param {?} method
             * @param {?} url
             * @param {?=} options
             * @return {?}
             */
                function (method, url, options) {
                    if (options === void 0) {
                        options = {};
                    }
                    if (!options.responseType) {
                        options.responseType = this._defaultResponseType;
                    }
                    if (!options.observe) {
                        options.observe = this._defaultObserve;
                    }
                    if (!options.headers) {
                        options.headers = this.buildHeaders();
                    }
                    else {
                        /** @type {?} */
                        var headers_1 = this.buildHeaders();
                        if (options.headers instanceof http.HttpHeaders) {
                            (( /** @type {?} */(options.headers))).keys().forEach(function (key) {
                                headers_1 = headers_1.set(key, (( /** @type {?} */(options.headers))).get(key));
                            });
                        }
                        else {
                            for (var key in options.headers) {
                                headers_1 = headers_1.set(key, ( /** @type {?} */(options.headers[key])));
                            }
                        }
                        options.headers = headers_1;
                    }
                    return (( /** @type {?} */(this.http))).request(method, url, options);
                };
            return class_1;
        }(HttpInternalClass));
    }
    /**
     * \@internal
     * WORKAROUND until Ivy Renderer is ready
     */
    var InternalHttpService = /** @class */ (function () {
        function InternalHttpService(_injector) {
            InternalHttpService._injector = _injector;
        }
        InternalHttpService._injector = undefined;
        InternalHttpService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        InternalHttpService.ctorParameters = function () {
            return [
                { type: i0.Injector }
            ];
        };
        /** @nocollapse */ InternalHttpService.ngInjectableDef = i0.defineInjectable({ factory: function InternalHttpService_Factory() { return new InternalHttpService(i0.inject(i0.INJECTOR)); }, token: InternalHttpService, providedIn: "root" });
        return InternalHttpService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Concrete implementation for http interceptor matchers.
     * This implementation uses regex to check mapping paths vs request url.
     */
    var /**
     * Concrete implementation for http interceptor matchers.
     * This implementation uses regex to check mapping paths vs request url.
     */ TdURLRegExpInterceptorMatcher = /** @class */ (function () {
        function TdURLRegExpInterceptorMatcher() {
        }
        /**
         * @param {?} options
         * @param {?} mapping
         * @return {?}
         */
        TdURLRegExpInterceptorMatcher.prototype.matches = /**
         * @param {?} options
         * @param {?} mapping
         * @return {?}
         */
            function (options, mapping) {
                return mapping.paths.filter(function (path) {
                    path = path.replace(/\*\*/gi, '<>')
                        .replace(/\*/gi, '[a-zA-Z0-9\\-_]+')
                        .replace(/<>/gi, '[a-zA-Z0-9\\-_\/]*');
                    if (path) {
                        path += '(\\?{1}.*)?$';
                        return new RegExp(path).test(options.url);
                    }
                    return false;
                }).length > 0;
            };
        return TdURLRegExpInterceptorMatcher;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var HTTP_CONFIG = new i0.InjectionToken('HTTP_CONFIG');
    /**
     * @param {?} handler
     * @param {?} injector
     * @param {?} config
     * @return {?}
     */
    function httpFactory(handler, injector, config) {
        return new TdHttpService(handler, new TdInterceptorBehaviorService(injector, new TdURLRegExpInterceptorMatcher(), config.interceptors));
    }
    /** @type {?} */
    var HTTP_INTERCEPTOR_PROVIDER = {
        provide: TdHttpService,
        useFactory: httpFactory,
        deps: [http.HttpHandler, i0.Injector, HTTP_CONFIG],
    };
    var CovalentHttpModule = /** @class */ (function () {
        function CovalentHttpModule(_internalHttpService) {
            this._internalHttpService = _internalHttpService;
        }
        /**
         * @param {?=} config
         * @return {?}
         */
        CovalentHttpModule.forRoot = /**
         * @param {?=} config
         * @return {?}
         */
            function (config) {
                if (config === void 0) {
                    config = { interceptors: [] };
                }
                return {
                    ngModule: CovalentHttpModule,
                    providers: [{
                            provide: HTTP_CONFIG,
                            useValue: config,
                        },
                        HTTP_INTERCEPTOR_PROVIDER,
                    ],
                };
            };
        CovalentHttpModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            http.HttpClientModule,
                        ],
                        providers: [
                            InternalHttpService,
                        ],
                    },] }
        ];
        /** @nocollapse */
        CovalentHttpModule.ctorParameters = function () {
            return [
                { type: InternalHttpService }
            ];
        };
        return CovalentHttpModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var tdHttpRESTParam = Symbol('TdHttpRESTParam');
    /**
     * Abstract implementation of the http param decorator
     * \@internal
     * @param {?} type
     * @param {?=} param
     * @return {?}
     */
    function TdAbstractParam(type, param) {
        return function (target, propertyKey, parameterIndex) {
            /** @type {?} */
            var parameters = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyKey) || [];
            parameters.push({
                index: parameterIndex,
                param: param,
                type: type,
            });
            Reflect.defineMetadata(tdHttpRESTParam, parameters, target, propertyKey);
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NOOP_HTTP = rxjs.of(undefined);
    /**
     * Method used to copy parameters from an array or HttpParams object
     * into a centrilized HttpParams object
     * \@internal
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    function parseParams(target, source) {
        /** @type {?} */
        var queryParams = target;
        if (source instanceof http.HttpParams) {
            source.keys().forEach(function (key) {
                // skip if value is undefined
                if ((( /** @type {?} */(source))).get(key) !== undefined) {
                    queryParams = queryParams.set(key, (( /** @type {?} */(source))).get(key));
                }
            });
        }
        else {
            for (var key in source) {
                // skip if value is undefined
                if (( /** @type {?} */(source[key])) !== undefined) {
                    queryParams = queryParams.set(key, ( /** @type {?} */(source[key])));
                }
            }
        }
        return queryParams;
    }
    /**
     * Abstract implementation of the http method decorator
     * \@internal
     * @param {?} config
     * @return {?}
     */
    function TdAbstractMethod(config) {
        return function (target, propertyName, descriptor) {
            /** @type {?} */
            var wrappedFunction = descriptor.value;
            // replace method call with our own and proxy it
            descriptor.value = function () {
                var e_1, _a, e_2, _b;
                try {
                    /** @type {?} */
                    var replacedPath = config.path;
                    /** @type {?} */
                    var parameters = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyName);
                    /** @type {?} */
                    var newArgs = [];
                    /** @type {?} */
                    var body = void 0;
                    /** @type {?} */
                    var queryParams = new http.HttpParams();
                    if (parameters) {
                        try {
                            // map parameters and see which type they are to act on them
                            for (var parameters_1 = __values(parameters), parameters_1_1 = parameters_1.next(); !parameters_1_1.done; parameters_1_1 = parameters_1.next()) {
                                var parameter = parameters_1_1.value;
                                if (parameter.type === 'param') {
                                    newArgs[parameter.index] = arguments[parameter.index];
                                    replacedPath = replacedPath.replace(':' + parameter.param, arguments[parameter.index]);
                                }
                                else if (parameter.type === 'body') {
                                    newArgs[parameter.index] = arguments[parameter.index];
                                    body = arguments[parameter.index];
                                }
                                else if (parameter.type === 'queryParams') {
                                    newArgs[parameter.index] = arguments[parameter.index];
                                    /** @type {?} */
                                    var qParams = arguments[parameter.index];
                                    if (config.options && config.options.params) {
                                        queryParams = parseParams(queryParams, config.options.params);
                                    }
                                    if (qParams) {
                                        queryParams = parseParams(queryParams, qParams);
                                    }
                                }
                            }
                        }
                        catch (e_1_1) {
                            e_1 = { error: e_1_1 };
                        }
                        finally {
                            try {
                                if (parameters_1_1 && !parameters_1_1.done && (_a = parameters_1.return))
                                    _a.call(parameters_1);
                            }
                            finally {
                                if (e_1)
                                    throw e_1.error;
                            }
                        }
                    }
                    // tslint:disable-next-line
                    /** @type {?} */
                    var url = this.baseUrl + replacedPath;
                    /** @type {?} */
                    var options = Object.assign({}, config.options, {
                        body: body,
                        params: queryParams,
                    });
                    // tslint:disable-next-line
                    /** @type {?} */
                    var request = this.buildRequest(config.method, url, options);
                    if (parameters) {
                        try {
                            // see which one was the response parameter so we can set the request observable
                            for (var parameters_2 = __values(parameters), parameters_2_1 = parameters_2.next(); !parameters_2_1.done; parameters_2_1 = parameters_2.next()) {
                                var parameter = parameters_2_1.value;
                                if (parameter.type === 'response') {
                                    newArgs[parameter.index] = request;
                                }
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (parameters_2_1 && !parameters_2_1.done && (_b = parameters_2.return))
                                    _b.call(parameters_2);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                    }
                    // tslint:disable-next-line
                    /** @type {?} */
                    var response = wrappedFunction.apply(this, newArgs);
                    // if the response is NOOP_HTTP or undefined, then we return the request as it is
                    // else we return the response from the inner function
                    if (response === NOOP_HTTP || response === undefined) {
                        return request;
                    }
                    else {
                        return response;
                    }
                }
                catch (error) {
                    // tslint:disable-next-line
                    console.error(error);
                }
            };
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that adds GET request capabilities to a method
     * @param {?} config
     * @return {?}
     */
    function TdGET(config) {
        return TdAbstractMethod(( /** @type {?} */(Object.assign({
            method: 'GET',
        }, config))));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that adds POST request capabilities to a method
     * @param {?} config
     * @return {?}
     */
    function TdPOST(config) {
        return TdAbstractMethod(( /** @type {?} */(Object.assign({
            method: 'POST',
        }, config))));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that adds PATCH request capabilities to a method
     * @param {?} config
     * @return {?}
     */
    function TdPATCH(config) {
        return TdAbstractMethod(( /** @type {?} */(Object.assign({
            method: 'PATCH',
        }, config))));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that adds PUT request capabilities to a method
     * @param {?} config
     * @return {?}
     */
    function TdPUT(config) {
        return TdAbstractMethod(( /** @type {?} */(Object.assign({
            method: 'PUT',
        }, config))));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that adds DELETE request capabilities to a method
     * @param {?} config
     * @return {?}
     */
    function TdDELETE(config) {
        return TdAbstractMethod(( /** @type {?} */(Object.assign({
            method: 'DELETE',
        }, config))));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator used to give a service http capabilities using TdHttpService
     * @param {?} config
     * @return {?}
     */
    function TdHttp(config) {
        return function (constructor) {
            return /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return class_1;
            }(mixinHttp(constructor, config, TdHttpService)));
        };
    }
    /**
     * Decorator used to give a service http capabilities using HttpClient
     * @param {?} config
     * @return {?}
     */
    function TdHttpClient(config) {
        return function (constructor) {
            return /** @class */ (function (_super) {
                __extends(class_2, _super);
                function class_2() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return class_2;
            }(mixinHttp(constructor, config, http.HttpClient)));
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that is used to define which parameter is an http parameter in a method
     * @param {?} param
     * @return {?}
     */
    function TdParam(param) {
        return TdAbstractParam('param', param);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that is used to define which parameter is the http body in a method
     * @return {?}
     */
    function TdBody() {
        return TdAbstractParam('body');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that is used to define which parameter is the http response in a method
     * @return {?}
     */
    function TdResponse() {
        return TdAbstractParam('response');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Decorator that is used to define which parameter is the http query parameters in a method
     * @return {?}
     */
    function TdQueryParams() {
        return TdAbstractParam('queryParams');
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    exports.TdHttpService = TdHttpService;
    exports.httpFactory = httpFactory;
    exports.HTTP_CONFIG = HTTP_CONFIG;
    exports.HTTP_INTERCEPTOR_PROVIDER = HTTP_INTERCEPTOR_PROVIDER;
    exports.CovalentHttpModule = CovalentHttpModule;
    exports.TdURLRegExpInterceptorMatcher = TdURLRegExpInterceptorMatcher;
    exports.TdGET = TdGET;
    exports.TdPOST = TdPOST;
    exports.TdPATCH = TdPATCH;
    exports.TdPUT = TdPUT;
    exports.TdDELETE = TdDELETE;
    exports.TdHttp = TdHttp;
    exports.TdHttpClient = TdHttpClient;
    exports.TdParam = TdParam;
    exports.TdBody = TdBody;
    exports.TdResponse = TdResponse;
    exports.TdQueryParams = TdQueryParams;
    exports.getInjector = getInjector;
    exports.mixinHttp = mixinHttp;
    exports.InternalHttpService = InternalHttpService;
    exports.ɵb = InternalHttpService;
    exports.ɵa = TdInterceptorBehaviorService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=covalent-http.umd.js.map