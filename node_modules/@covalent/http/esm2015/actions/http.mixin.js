/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { Injectable, Injector, ɵReflectionCapabilities, Optional, SkipSelf, Self, Inject, inject, INJECTOR } from '@angular/core';
import { HttpHeaders } from '@angular/common/http';
import { TdHttpService } from '../interceptors/http.service';
import * as i0 from "@angular/core";
/**
 * @record
 */
export function ITdHttpRESTConfig() { }
if (false) {
    /** @type {?|undefined} */
    ITdHttpRESTConfig.prototype.baseHeaders;
    /** @type {?} */
    ITdHttpRESTConfig.prototype.baseUrl;
    /** @type {?|undefined} */
    ITdHttpRESTConfig.prototype.defaultObserve;
    /** @type {?|undefined} */
    ITdHttpRESTConfig.prototype.defaultResponseType;
}
/**
 * DO NOT MODIFY
 * Taken from angular since they dont expose this function
 * This is used internally to inject services from the constructor of the base service using the mixinHttp
 * \@internal
 * @param {?} types
 * @param {?} injector
 * @return {?}
 */
function injectArgs(types, injector) {
    /** @type {?} */
    const args = [];
    for (let i = 0; i < types.length; i++) {
        /** @type {?} */
        const arg = types[i];
        if (arg) {
            if (Array.isArray(arg)) {
                if (arg.length === 0) {
                    throw new Error('Arguments array must have arguments.');
                }
                /** @type {?} */
                let type = undefined;
                /** @type {?} */
                let flags = 0 /* Default */;
                for (let j = 0; j < arg.length; j++) {
                    /** @type {?} */
                    const meta = arg[j];
                    if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {
                        /* tslint:disable */
                        flags |= 8 /* Optional */;
                    }
                    else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {
                        flags |= 4 /* SkipSelf */;
                    }
                    else if (meta instanceof Self || meta.ngMetadataName === 'Self') {
                        flags |= 2 /* Self */;
                    }
                    else if (meta instanceof Inject) {
                        type = meta.token;
                    }
                    else {
                        type = meta;
                    }
                    /* tslint:enable */
                }
                args.push(injector.get((/** @type {?} */ (type)), flags));
            }
            else {
                args.push(injector.get(arg));
            }
        }
    }
    return args;
}
/**
 * @return {?}
 */
export function getInjector() {
    try {
        return inject(INJECTOR);
    }
    catch (e) {
        if (!InternalHttpService._injector) {
            throw new Error('Please add CovalentHttpModule into your imports.');
        }
        return InternalHttpService._injector;
    }
}
/**
 * Mixin to augment a service with http helpers.
 * \@internal
 * @param {?} base
 * @param {?} config
 * @param {?=} httpInject
 * @return {?}
 */
export function mixinHttp(base, config, httpInject = TdHttpService) {
    /**
     * Internal class used to get an instance of Injector for internal usage plus also
     * a way to inject services from the constructor of the underlying service
     * \@internal
     * @abstract
     */
    class HttpInternalClass extends base {
        /**
         * @param {...?} args
         */
        constructor(...args) {
            super(...(args && args.length ? args : injectArgs(new ɵReflectionCapabilities().parameters(base), getInjector())));
            this._injector = getInjector();
            this.buildConfig();
        }
    }
    if (false) {
        /**
         * @abstract
         * @return {?}
         */
        HttpInternalClass.prototype.buildConfig = function () { };
    }
    /**
     * Actuall class being returned with all the hooks for http usage
     * @internal
     */
    return class extends HttpInternalClass {
        /**
         * @return {?}
         */
        get baseUrl() {
            return (typeof (this.basePath) === 'string' ?
                this.basePath.replace(/\/$/, '') : '') + this._baseUrl;
        }
        /**
         * Method used to setup the configuration parameters and get an instance of the http service
         * @return {?}
         */
        buildConfig() {
            this.http = this._injector.get(httpInject);
            this._baseUrl = config && config.baseUrl ? config.baseUrl.replace(/\/$/, '') : '';
            this._baseHeaders = config && config.baseHeaders ? config.baseHeaders : new HttpHeaders();
            this._defaultObserve = config && config.defaultObserve ? config.defaultObserve : 'body';
            this._defaultResponseType = config && config.defaultResponseType ? config.defaultResponseType : 'json';
        }
        /**
         * Method used to build the default headers using the base headers
         * @return {?}
         */
        buildHeaders() {
            /** @type {?} */
            let headersObj = {};
            this._baseHeaders.keys().forEach((key) => {
                headersObj[key] = this._baseHeaders.get(key);
            });
            return new HttpHeaders(headersObj);
        }
        /* tslint:disable-next-line */
        /**
         * @template HttpResponse
         * @param {?} method
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        buildRequest(method, url, options) {
            return this._buildRequest(method, url, options);
        }
        /**
         * Method used to build the request depending on the `http` service and TdHttpMethod
         * @param {?} method
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        _buildRequest(method, url, options = {}) {
            if (!options.responseType) {
                options.responseType = this._defaultResponseType;
            }
            if (!options.observe) {
                options.observe = this._defaultObserve;
            }
            if (!options.headers) {
                options.headers = this.buildHeaders();
            }
            else {
                /** @type {?} */
                let headers = this.buildHeaders();
                if (options.headers instanceof HttpHeaders) {
                    ((/** @type {?} */ (options.headers))).keys().forEach((key) => {
                        headers = headers.set(key, ((/** @type {?} */ (options.headers))).get(key));
                    });
                }
                else {
                    for (let key in options.headers) {
                        headers = headers.set(key, (/** @type {?} */ (options.headers[key])));
                    }
                }
                options.headers = headers;
            }
            return ((/** @type {?} */ (this.http))).request(method, url, options);
        }
    };
}
/**
 * \@internal
 * WORKAROUND until Ivy Renderer is ready
 */
export class InternalHttpService {
    /**
     * @param {?} _injector
     */
    constructor(_injector) {
        InternalHttpService._injector = _injector;
    }
}
InternalHttpService._injector = undefined;
InternalHttpService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
InternalHttpService.ctorParameters = () => [
    { type: Injector }
];
/** @nocollapse */ InternalHttpService.ngInjectableDef = i0.defineInjectable({ factory: function InternalHttpService_Factory() { return new InternalHttpService(i0.inject(i0.INJECTOR)); }, token: InternalHttpService, providedIn: "root" });
if (false) {
    /** @type {?} */
    InternalHttpService._injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC5taXhpbi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bjb3ZhbGVudC9odHRwLyIsInNvdXJjZXMiOlsiYWN0aW9ucy9odHRwLm1peGluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQVEsVUFBVSxFQUFFLFFBQVEsRUFBRSx1QkFBdUIsRUFBZSxRQUFRLEVBQ2pGLFFBQVEsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFrQixNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xGLE9BQU8sRUFBYyxXQUFXLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sOEJBQThCLENBQUM7Ozs7O0FBTTdELHVDQUtDOzs7SUFKQyx3Q0FBMEI7O0lBQzFCLG9DQUFnQjs7SUFDaEIsMkNBQW1DOztJQUNuQyxnREFBNkM7Ozs7Ozs7Ozs7O0FBVy9DLFNBQVMsVUFBVSxDQUFDLEtBQWdELEVBQUUsUUFBa0I7O1VBQ2hGLElBQUksR0FBVSxFQUFFO0lBQ3RCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFOztjQUN2QyxHQUFHLEdBQVEsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN6QixJQUFJLEdBQUcsRUFBRTtZQUNQLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDdEIsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO2lCQUN6RDs7b0JBQ0csSUFBSSxHQUF3QixTQUFTOztvQkFDckMsS0FBSyxrQkFBbUM7Z0JBRTVDLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFOzswQkFDckMsSUFBSSxHQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ3hCLElBQUksSUFBSSxZQUFZLFFBQVEsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLFVBQVUsRUFBRTt3QkFDbEUsb0JBQW9CO3dCQUNwQixLQUFLLG9CQUF3QixDQUFDO3FCQUMvQjt5QkFBTSxJQUFJLElBQUksWUFBWSxRQUFRLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxVQUFVLEVBQUU7d0JBQ3pFLEtBQUssb0JBQXdCLENBQUM7cUJBQy9CO3lCQUFNLElBQUksSUFBSSxZQUFZLElBQUksSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLE1BQU0sRUFBRTt3QkFDakUsS0FBSyxnQkFBb0IsQ0FBQztxQkFDM0I7eUJBQU0sSUFBSSxJQUFJLFlBQVksTUFBTSxFQUFFO3dCQUNqQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztxQkFDbkI7eUJBQU07d0JBQ0wsSUFBSSxHQUFHLElBQUksQ0FBQztxQkFDYjtvQkFDRCxtQkFBbUI7aUJBQ3BCO2dCQUVELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxtQkFBQSxJQUFJLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQ3hDO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQzlCO1NBQ0Y7S0FDRjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQzs7OztBQUVELE1BQU0sVUFBVSxXQUFXO0lBQ3pCLElBQUk7UUFDRixPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUN6QjtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRTtZQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7U0FDckU7UUFDRCxPQUFPLG1CQUFtQixDQUFDLFNBQVMsQ0FBQztLQUN0QztBQUNILENBQUM7Ozs7Ozs7OztBQU1ELE1BQU0sVUFBVSxTQUFTLENBQUMsSUFBUyxFQUNULE1BQXlCLEVBQ3pCLGFBQStDLGFBQWE7Ozs7Ozs7SUFNcEYsTUFBZSxpQkFBa0IsU0FBUSxJQUFJOzs7O1FBQzNDLFlBQVksR0FBRyxJQUFXO1lBQ3hCLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksdUJBQXVCLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkgsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLEVBQUUsQ0FBQztZQUMvQixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDckIsQ0FBQztLQUVGOzs7Ozs7UUFEQywwREFBNkI7O0lBRS9COzs7T0FHRztJQUNILE9BQU8sS0FBTSxTQUFRLGlCQUFpQjs7OztRQUVwQyxJQUFJLE9BQU87WUFDVCxPQUFPLENBQUMsT0FBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzNELENBQUM7Ozs7O1FBVUQsV0FBVztZQUNULElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDbEYsSUFBSSxDQUFDLFlBQVksR0FBRyxNQUFNLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxXQUFXLEVBQUUsQ0FBQztZQUMxRixJQUFJLENBQUMsZUFBZSxHQUFHLE1BQU0sSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7WUFDeEYsSUFBSSxDQUFDLG9CQUFvQixHQUFHLE1BQU0sSUFBSSxNQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3pHLENBQUM7Ozs7O1FBS0QsWUFBWTs7Z0JBQ04sVUFBVSxHQUF5QixFQUFFO1lBQ3pDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBUSxFQUFFLEVBQUU7Z0JBQzVDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMvQyxDQUFDLENBQUMsQ0FBQztZQUNILE9BQU8sSUFBSSxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckMsQ0FBQzs7Ozs7Ozs7O1FBTUQsWUFBWSxDQUFlLE1BQW9CLEVBQUUsR0FBVyxFQUFFLE9BQW9DO1lBQ2hHLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2xELENBQUM7Ozs7Ozs7O1FBS08sYUFBYSxDQUFDLE1BQW9CLEVBQUUsR0FBVyxFQUFFLFVBQXNDLEVBQUU7WUFDL0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ3pCLE9BQU8sQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDO2FBQ2xEO1lBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7Z0JBQ3BCLE9BQU8sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQzthQUN4QztZQUNELElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO2dCQUNwQixPQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUN2QztpQkFBTTs7b0JBQ0QsT0FBTyxHQUFnQixJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUM5QyxJQUFJLE9BQU8sQ0FBQyxPQUFPLFlBQVksV0FBVyxFQUFFO29CQUMxQyxDQUFDLG1CQUFhLE9BQU8sQ0FBQyxPQUFPLEVBQUEsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQVEsRUFBRSxFQUFFO3dCQUN6RCxPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxtQkFBYSxPQUFPLENBQUMsT0FBTyxFQUFBLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztvQkFDdEUsQ0FBQyxDQUFDLENBQUM7aUJBQ0o7cUJBQU07b0JBQ0wsS0FBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLENBQUMsT0FBTyxFQUFFO3dCQUMvQixPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsbUJBQUssT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBQSxDQUFDLENBQUM7cUJBQ3ZEO2lCQUNGO2dCQUNELE9BQU8sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO2FBQzNCO1lBQ0QsT0FBTyxDQUFDLG1CQUFlLElBQUksQ0FBQyxJQUFJLEVBQUEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2xFLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQzs7Ozs7QUFPRCxNQUFNLE9BQU8sbUJBQW1COzs7O0lBSTlCLFlBQVksU0FBbUI7UUFDN0IsbUJBQW1CLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztJQUM1QyxDQUFDOztBQUpNLDZCQUFTLEdBQWEsU0FBUyxDQUFDOztZQUh4QyxVQUFVLFNBQUMsRUFBQyxVQUFVLEVBQUUsTUFBTSxFQUFDOzs7O1lBN0tMLFFBQVE7Ozs7O0lBZ0xqQyw4QkFBdUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUeXBlLCBJbmplY3RhYmxlLCBJbmplY3RvciwgybVSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLCBJbmplY3RGbGFncywgT3B0aW9uYWwsXG4gIFNraXBTZWxmLCBTZWxmLCBJbmplY3QsIEluamVjdGlvblRva2VuLCBpbmplY3QsIElOSkVDVE9SIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50LCBIdHRwSGVhZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IFRkSHR0cFNlcnZpY2UgfSBmcm9tICcuLi9pbnRlcmNlcHRvcnMvaHR0cC5zZXJ2aWNlJztcblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJVGRIdHRwUkVTVE9wdGlvbnMsIElUZEh0dHBSRVNUT3B0aW9uc1dpdGhCb2R5LCBUZEh0dHBSRVNUUmVzcG9uc2VUeXBlLCBUZEh0dHBSRVNUT2JzZXJ2ZSwgVGRIdHRwTWV0aG9kIH0gZnJvbSAnLi4vaHR0cC5pbnRlcmZhY2VzJztcblxuZXhwb3J0IGludGVyZmFjZSBJVGRIdHRwUkVTVENvbmZpZyB7XG4gIGJhc2VIZWFkZXJzPzogSHR0cEhlYWRlcnM7XG4gIGJhc2VVcmw6IHN0cmluZztcbiAgZGVmYXVsdE9ic2VydmU/OiBUZEh0dHBSRVNUT2JzZXJ2ZTtcbiAgZGVmYXVsdFJlc3BvbnNlVHlwZT86IFRkSHR0cFJFU1RSZXNwb25zZVR5cGU7XG59XG5cbnR5cGUgQ29uc3RydWN0b3I8VD4gPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUO1xuXG4vKipcbiAqIERPIE5PVCBNT0RJRllcbiAqIFRha2VuIGZyb20gYW5ndWxhciBzaW5jZSB0aGV5IGRvbnQgZXhwb3NlIHRoaXMgZnVuY3Rpb25cbiAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdCBzZXJ2aWNlcyBmcm9tIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgYmFzZSBzZXJ2aWNlIHVzaW5nIHRoZSBtaXhpbkh0dHBcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpbmplY3RBcmdzKHR5cGVzOiAoVHlwZTxhbnk+fCBJbmplY3Rpb25Ub2tlbjxhbnk+fCBhbnlbXSlbXSwgaW5qZWN0b3I6IEluamVjdG9yKTogYW55W10ge1xuICBjb25zdCBhcmdzOiBhbnlbXSA9IFtdO1xuICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmc6IGFueSA9IHR5cGVzW2ldO1xuICAgIGlmIChhcmcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgaWYgKGFyZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50cyBhcnJheSBtdXN0IGhhdmUgYXJndW1lbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlOiBUeXBlPGFueT58dW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZmxhZ3M6IEluamVjdEZsYWdzID0gSW5qZWN0RmxhZ3MuRGVmYXVsdDtcblxuICAgICAgICBmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgYXJnLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgbWV0YTogYW55ID0gYXJnW2pdO1xuICAgICAgICAgIGlmIChtZXRhIGluc3RhbmNlb2YgT3B0aW9uYWwgfHwgbWV0YS5uZ01ldGFkYXRhTmFtZSA9PT0gJ09wdGlvbmFsJykge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAgICAgICAgIGZsYWdzIHw9IEluamVjdEZsYWdzLk9wdGlvbmFsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YSBpbnN0YW5jZW9mIFNraXBTZWxmIHx8IG1ldGEubmdNZXRhZGF0YU5hbWUgPT09ICdTa2lwU2VsZicpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IEluamVjdEZsYWdzLlNraXBTZWxmO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YSBpbnN0YW5jZW9mIFNlbGYgfHwgbWV0YS5uZ01ldGFkYXRhTmFtZSA9PT0gJ1NlbGYnKSB7XG4gICAgICAgICAgICBmbGFncyB8PSBJbmplY3RGbGFncy5TZWxmO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YSBpbnN0YW5jZW9mIEluamVjdCkge1xuICAgICAgICAgICAgdHlwZSA9IG1ldGEudG9rZW47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSBtZXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXG4gICAgICAgIH1cblxuICAgICAgICBhcmdzLnB1c2goaW5qZWN0b3IuZ2V0KHR5cGUgISwgZmxhZ3MpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MucHVzaChpbmplY3Rvci5nZXQoYXJnKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmdzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5qZWN0b3IoKTogSW5qZWN0b3Ige1xuICB0cnkge1xuICAgIHJldHVybiBpbmplY3QoSU5KRUNUT1IpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCFJbnRlcm5hbEh0dHBTZXJ2aWNlLl9pbmplY3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgYWRkIENvdmFsZW50SHR0cE1vZHVsZSBpbnRvIHlvdXIgaW1wb3J0cy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIEludGVybmFsSHR0cFNlcnZpY2UuX2luamVjdG9yO1xuICB9XG59XG5cbi8qKiBcbiAqIE1peGluIHRvIGF1Z21lbnQgYSBzZXJ2aWNlIHdpdGggaHR0cCBoZWxwZXJzLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbkh0dHAoYmFzZTogYW55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IElUZEh0dHBSRVNUQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwSW5qZWN0OiBUeXBlPEh0dHBDbGllbnQgfCBUZEh0dHBTZXJ2aWNlPiA9IFRkSHR0cFNlcnZpY2UpOiBDb25zdHJ1Y3Rvcjxhbnk+IHtcbiAgLyoqXG4gICAqIEludGVybmFsIGNsYXNzIHVzZWQgdG8gZ2V0IGFuIGluc3RhbmNlIG9mIEluamVjdG9yIGZvciBpbnRlcm5hbCB1c2FnZSBwbHVzIGFsc29cbiAgICogYSB3YXkgdG8gaW5qZWN0IHNlcnZpY2VzIGZyb20gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSB1bmRlcmx5aW5nIHNlcnZpY2VcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhYnN0cmFjdCBjbGFzcyBIdHRwSW50ZXJuYWxDbGFzcyBleHRlbmRzIGJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICBzdXBlciguLi4oYXJncyAmJiBhcmdzLmxlbmd0aCA/IGFyZ3MgOiBpbmplY3RBcmdzKG5ldyDJtVJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKS5wYXJhbWV0ZXJzKGJhc2UpLCBnZXRJbmplY3RvcigpKSkpO1xuICAgICAgdGhpcy5faW5qZWN0b3IgPSBnZXRJbmplY3RvcigpO1xuICAgICAgdGhpcy5idWlsZENvbmZpZygpO1xuICAgIH1cbiAgICBhYnN0cmFjdCBidWlsZENvbmZpZygpOiB2b2lkO1xuICB9XG4gIC8qKlxuICAgKiBBY3R1YWxsIGNsYXNzIGJlaW5nIHJldHVybmVkIHdpdGggYWxsIHRoZSBob29rcyBmb3IgaHR0cCB1c2FnZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJldHVybiBjbGFzcyBleHRlbmRzIEh0dHBJbnRlcm5hbENsYXNzIHtcbiAgICBwcml2YXRlIF9iYXNlVXJsOiBzdHJpbmc7XG4gICAgZ2V0IGJhc2VVcmwoKTogc3RyaW5nIHtcbiAgICAgIHJldHVybiAodHlwZW9mKHRoaXMuYmFzZVBhdGgpID09PSAnc3RyaW5nJyA/XG4gICAgICAgIHRoaXMuYmFzZVBhdGgucmVwbGFjZSgvXFwvJC8sICcnKSA6ICcnKSArIHRoaXMuX2Jhc2VVcmw7XG4gICAgfVxuICAgIHByaXZhdGUgX2Jhc2VIZWFkZXJzOiBIdHRwSGVhZGVycztcbiAgICBwcml2YXRlIF9kZWZhdWx0T2JzZXJ2ZT86IFRkSHR0cFJFU1RPYnNlcnZlO1xuICAgIHByaXZhdGUgX2RlZmF1bHRSZXNwb25zZVR5cGU/OiBUZEh0dHBSRVNUUmVzcG9uc2VUeXBlO1xuXG4gICAgaHR0cDogSHR0cENsaWVudCB8IFRkSHR0cFNlcnZpY2U7XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzZXR1cCB0aGUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGFuZCBnZXQgYW4gaW5zdGFuY2Ugb2YgdGhlIGh0dHAgc2VydmljZVxuICAgICAqL1xuICAgIGJ1aWxkQ29uZmlnKCk6IHZvaWQge1xuICAgICAgdGhpcy5odHRwID0gdGhpcy5faW5qZWN0b3IuZ2V0KGh0dHBJbmplY3QpO1xuICAgICAgdGhpcy5fYmFzZVVybCA9IGNvbmZpZyAmJiBjb25maWcuYmFzZVVybCA/IGNvbmZpZy5iYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCAnJykgOiAnJztcbiAgICAgIHRoaXMuX2Jhc2VIZWFkZXJzID0gY29uZmlnICYmIGNvbmZpZy5iYXNlSGVhZGVycyA/IGNvbmZpZy5iYXNlSGVhZGVycyA6IG5ldyBIdHRwSGVhZGVycygpO1xuICAgICAgdGhpcy5fZGVmYXVsdE9ic2VydmUgPSBjb25maWcgJiYgY29uZmlnLmRlZmF1bHRPYnNlcnZlID8gY29uZmlnLmRlZmF1bHRPYnNlcnZlIDogJ2JvZHknO1xuICAgICAgdGhpcy5fZGVmYXVsdFJlc3BvbnNlVHlwZSA9IGNvbmZpZyAmJiBjb25maWcuZGVmYXVsdFJlc3BvbnNlVHlwZSA/IGNvbmZpZy5kZWZhdWx0UmVzcG9uc2VUeXBlIDogJ2pzb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGJ1aWxkIHRoZSBkZWZhdWx0IGhlYWRlcnMgdXNpbmcgdGhlIGJhc2UgaGVhZGVyc1xuICAgICAqL1xuICAgIGJ1aWxkSGVhZGVycygpOiBIdHRwSGVhZGVycyB7XG4gICAgICBsZXQgaGVhZGVyc09iajoge1trZXk6IHN0cmluZ106IGFueX0gPSB7fTtcbiAgICAgIHRoaXMuX2Jhc2VIZWFkZXJzLmtleXMoKS5mb3JFYWNoKChrZXk6IGFueSkgPT4ge1xuICAgICAgICBoZWFkZXJzT2JqW2tleV0gPSB0aGlzLl9iYXNlSGVhZGVycy5nZXQoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBIdHRwSGVhZGVycyhoZWFkZXJzT2JqKTtcbiAgICB9XG4gICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gICAgYnVpbGRSZXF1ZXN0PEh0dHBSZXNwb25zZT4obWV0aG9kOiAnUE9TVCcgfCAnUFVUJyB8ICdQQVRDSCcsIHVybDogc3RyaW5nLCBvcHRpb25zPzogSVRkSHR0cFJFU1RPcHRpb25zV2l0aEJvZHkpOiBPYnNlcnZhYmxlPEh0dHBSZXNwb25zZT47XG4gICAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gICAgYnVpbGRSZXF1ZXN0PEh0dHBSZXNwb25zZT4obWV0aG9kOiAnR0VUJyB8ICdERUxFVEUnLCB1cmw6IHN0cmluZywgb3B0aW9ucz86IElUZEh0dHBSRVNUT3B0aW9ucyk6IE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPjtcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICBidWlsZFJlcXVlc3Q8SHR0cFJlc3BvbnNlPihtZXRob2Q6IFRkSHR0cE1ldGhvZCwgdXJsOiBzdHJpbmcsIG9wdGlvbnM/OiBJVGRIdHRwUkVTVE9wdGlvbnNXaXRoQm9keSk6IE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBidWlsZCB0aGUgcmVxdWVzdCBkZXBlbmRpbmcgb24gdGhlIGBodHRwYCBzZXJ2aWNlIGFuZCBUZEh0dHBNZXRob2RcbiAgICAgKi9cbiAgICBwcml2YXRlIF9idWlsZFJlcXVlc3QobWV0aG9kOiBUZEh0dHBNZXRob2QsIHVybDogc3RyaW5nLCBvcHRpb25zOiBJVGRIdHRwUkVTVE9wdGlvbnNXaXRoQm9keSA9IHt9KTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAgIGlmICghb3B0aW9ucy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgb3B0aW9ucy5yZXNwb25zZVR5cGUgPSB0aGlzLl9kZWZhdWx0UmVzcG9uc2VUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLm9ic2VydmUpIHtcbiAgICAgICAgb3B0aW9ucy5vYnNlcnZlID0gdGhpcy5fZGVmYXVsdE9ic2VydmU7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB0aGlzLmJ1aWxkSGVhZGVycygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGhlYWRlcnM6IEh0dHBIZWFkZXJzID0gdGhpcy5idWlsZEhlYWRlcnMoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEh0dHBIZWFkZXJzKSB7XG4gICAgICAgICAgKDxIdHRwSGVhZGVycz5vcHRpb25zLmhlYWRlcnMpLmtleXMoKS5mb3JFYWNoKChrZXk6IGFueSkgPT4ge1xuICAgICAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMuc2V0KGtleSwgKDxIdHRwSGVhZGVycz5vcHRpb25zLmhlYWRlcnMpLmdldChrZXkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBoZWFkZXJzID0gaGVhZGVycy5zZXQoa2V5LCA8YW55Pm9wdGlvbnMuaGVhZGVyc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoPFRkSHR0cFNlcnZpY2U+dGhpcy5odHRwKS5yZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKiBcbiAqIEBpbnRlcm5hbFxuICogV09SS0FST1VORCB1bnRpbCBJdnkgUmVuZGVyZXIgaXMgcmVhZHlcbiAqL1xuQEluamVjdGFibGUoe3Byb3ZpZGVkSW46ICdyb290J30pXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxIdHRwU2VydmljZSB7XG5cbiAgc3RhdGljIF9pbmplY3RvcjogSW5qZWN0b3IgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoX2luamVjdG9yOiBJbmplY3Rvcikge1xuICAgIEludGVybmFsSHR0cFNlcnZpY2UuX2luamVjdG9yID0gX2luamVjdG9yO1xuICB9XG59XG4iXX0=