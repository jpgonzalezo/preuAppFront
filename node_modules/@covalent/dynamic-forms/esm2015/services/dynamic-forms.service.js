/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { Injectable, SkipSelf, Optional } from '@angular/core';
import { Validators, FormControl } from '@angular/forms';
import { TdDynamicInputComponent } from '../dynamic-elements/dynamic-input/dynamic-input.component';
import { TdDynamicFileInputComponent } from '../dynamic-elements/dynamic-file-input/dynamic-file-input.component';
import { TdDynamicTextareaComponent } from '../dynamic-elements/dynamic-textarea/dynamic-textarea.component';
import { TdDynamicSlideToggleComponent } from '../dynamic-elements/dynamic-slide-toggle/dynamic-slide-toggle.component';
import { TdDynamicCheckboxComponent } from '../dynamic-elements/dynamic-checkbox/dynamic-checkbox.component';
import { TdDynamicSliderComponent } from '../dynamic-elements/dynamic-slider/dynamic-slider.component';
import { TdDynamicSelectComponent } from '../dynamic-elements/dynamic-select/dynamic-select.component';
import { TdDynamicDatepickerComponent } from '../dynamic-elements/dynamic-datepicker/dynamic-datepicker.component';
/** @enum {string} */
const TdDynamicType = {
    Text: 'text',
    Boolean: 'boolean',
    Number: 'number',
    Array: 'array',
    Date: 'date',
};
export { TdDynamicType };
/** @enum {string} */
const TdDynamicElement = {
    Input: 'input',
    Datepicker: 'datepicker',
    Password: 'password',
    Textarea: 'textarea',
    Slider: 'slider',
    SlideToggle: 'slide-toggle',
    Checkbox: 'checkbox',
    Select: 'select',
    FileInput: 'file-input',
};
export { TdDynamicElement };
/**
 * @record
 */
export function ITdDynamicElementValidator() { }
if (false) {
    /** @type {?} */
    ITdDynamicElementValidator.prototype.validator;
}
/**
 * @record
 */
export function ITdDynamicElementConfig() { }
if (false) {
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.label;
    /** @type {?} */
    ITdDynamicElementConfig.prototype.name;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.hint;
    /** @type {?} */
    ITdDynamicElementConfig.prototype.type;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.required;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.disabled;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.min;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.max;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.minLength;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.maxLength;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.selections;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.multiple;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.default;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.flex;
    /** @type {?|undefined} */
    ITdDynamicElementConfig.prototype.validators;
}
/** @type {?} */
export const DYNAMIC_ELEMENT_NAME_REGEX = /^[^0-9][^\@]*$/;
export class TdDynamicFormsService {
    /**
     * Method to validate if the [name] is a proper element name.
     * Throws error if name is not valid.
     * @param {?} name
     * @return {?}
     */
    validateDynamicElementName(name) {
        if (!DYNAMIC_ELEMENT_NAME_REGEX.test(name)) {
            throw new Error('Dynamic element name: "${name}" is not valid.');
        }
    }
    /**
     * Gets component to be rendered depending on [TdDynamicElement | TdDynamicType]
     * Throws error if it does not exists or not supported.
     * @param {?} element
     * @return {?}
     */
    getDynamicElement(element) {
        switch (element) {
            case TdDynamicType.Text:
            case TdDynamicType.Number:
            case TdDynamicElement.Input:
            case TdDynamicElement.Password:
                return TdDynamicInputComponent;
            case TdDynamicElement.Textarea:
                return TdDynamicTextareaComponent;
            case TdDynamicType.Boolean:
            case TdDynamicElement.SlideToggle:
                return TdDynamicSlideToggleComponent;
            case TdDynamicElement.Checkbox:
                return TdDynamicCheckboxComponent;
            case TdDynamicElement.Slider:
                return TdDynamicSliderComponent;
            case TdDynamicType.Array:
            case TdDynamicElement.Select:
                return TdDynamicSelectComponent;
            case TdDynamicElement.FileInput:
                return TdDynamicFileInputComponent;
            case TdDynamicElement.Datepicker:
            case TdDynamicType.Date:
                return TdDynamicDatepickerComponent;
            default:
                throw new Error(`Error: type ${element} does not exist or not supported.`);
        }
    }
    /**
     * Creates form control for element depending [ITdDynamicElementConfig] properties.
     * @param {?} config
     * @return {?}
     */
    createFormControl(config) {
        /** @type {?} */
        let validator = this.createValidators(config);
        return new FormControl({ value: config.default, disabled: config.disabled }, validator);
    }
    /**
     * Creates form validationdepending [ITdDynamicElementConfig] properties.
     * @param {?} config
     * @return {?}
     */
    createValidators(config) {
        /** @type {?} */
        let validator;
        if (config.required) {
            validator = Validators.required;
        }
        if (config.max || config.max === 0) {
            validator = Validators.compose([validator, Validators.max(parseFloat(config.max))]);
        }
        if (config.min || config.min === 0) {
            validator = Validators.compose([validator, Validators.min(parseFloat(config.min))]);
        }
        if (config.maxLength || config.maxLength === 0) {
            validator = Validators.compose([validator, Validators.maxLength(parseFloat(config.maxLength))]);
        }
        if (config.minLength || config.minLength === 0) {
            validator = Validators.compose([validator, Validators.minLength(parseFloat(config.minLength))]);
        }
        // Add provided custom validators to the validator function
        if (config.validators) {
            config.validators.forEach((validatorConfig) => {
                validator = Validators.compose([validator, validatorConfig.validator]);
            });
        }
        return validator;
    }
}
TdDynamicFormsService.decorators = [
    { type: Injectable }
];
/**
 * @param {?} parent
 * @return {?}
 */
export function DYNAMIC_FORMS_PROVIDER_FACTORY(parent) {
    return parent || new TdDynamicFormsService();
}
/** @type {?} */
export const DYNAMIC_FORMS_PROVIDER = {
    // If there is already a service available, use that. Otherwise, provide a new one.
    provide: TdDynamicFormsService,
    deps: [[new Optional(), new SkipSelf(), TdDynamicFormsService]],
    useFactory: DYNAMIC_FORMS_PROVIDER_FACTORY,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHluYW1pYy1mb3Jtcy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGNvdmFsZW50L2R5bmFtaWMtZm9ybXMvIiwic291cmNlcyI6WyJzZXJ2aWNlcy9keW5hbWljLWZvcm1zLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQVksUUFBUSxFQUFFLFFBQVEsRUFBUSxNQUFNLGVBQWUsQ0FBQztBQUMvRSxPQUFPLEVBQUUsVUFBVSxFQUFlLFdBQVcsRUFBbUIsTUFBTSxnQkFBZ0IsQ0FBQztBQUV2RixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSwyREFBMkQsQ0FBQztBQUNwRyxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxxRUFBcUUsQ0FBQztBQUNsSCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxpRUFBaUUsQ0FBQztBQUM3RyxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSx5RUFBeUUsQ0FBQztBQUN4SCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxpRUFBaUUsQ0FBQztBQUM3RyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw2REFBNkQsQ0FBQztBQUN2RyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw2REFBNkQsQ0FBQztBQUN2RyxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSxxRUFBcUUsQ0FBQzs7O0lBR2pILE1BQU8sTUFBTTtJQUNiLFNBQVUsU0FBUztJQUNuQixRQUFTLFFBQVE7SUFDakIsT0FBUSxPQUFPO0lBQ2YsTUFBTyxNQUFNOzs7OztJQUliLE9BQVEsT0FBTztJQUNmLFlBQWEsWUFBWTtJQUN6QixVQUFXLFVBQVU7SUFDckIsVUFBVyxVQUFVO0lBQ3JCLFFBQVMsUUFBUTtJQUNqQixhQUFjLGNBQWM7SUFDNUIsVUFBVyxVQUFVO0lBQ3JCLFFBQVMsUUFBUTtJQUNqQixXQUFZLFlBQVk7Ozs7OztBQUcxQixnREFFQzs7O0lBREMsK0NBQXVCOzs7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QkFBOEI7Q0FDM0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBQcm92aWRlciwgU2tpcFNlbGYsIE9wdGlvbmFsLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBWYWxpZGF0b3JzLCBWYWxpZGF0b3JGbiwgRm9ybUNvbnRyb2wsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgVGREeW5hbWljSW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi9keW5hbWljLWVsZW1lbnRzL2R5bmFtaWMtaW5wdXQvZHluYW1pYy1pbnB1dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGREeW5hbWljRmlsZUlucHV0Q29tcG9uZW50IH0gZnJvbSAnLi4vZHluYW1pYy1lbGVtZW50cy9keW5hbWljLWZpbGUtaW5wdXQvZHluYW1pYy1maWxlLWlucHV0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUZER5bmFtaWNUZXh0YXJlYUNvbXBvbmVudCB9IGZyb20gJy4uL2R5bmFtaWMtZWxlbWVudHMvZHluYW1pYy10ZXh0YXJlYS9keW5hbWljLXRleHRhcmVhLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUZER5bmFtaWNTbGlkZVRvZ2dsZUNvbXBvbmVudCB9IGZyb20gJy4uL2R5bmFtaWMtZWxlbWVudHMvZHluYW1pYy1zbGlkZS10b2dnbGUvZHluYW1pYy1zbGlkZS10b2dnbGUuY29tcG9uZW50JztcbmltcG9ydCB7IFRkRHluYW1pY0NoZWNrYm94Q29tcG9uZW50IH0gZnJvbSAnLi4vZHluYW1pYy1lbGVtZW50cy9keW5hbWljLWNoZWNrYm94L2R5bmFtaWMtY2hlY2tib3guY29tcG9uZW50JztcbmltcG9ydCB7IFRkRHluYW1pY1NsaWRlckNvbXBvbmVudCB9IGZyb20gJy4uL2R5bmFtaWMtZWxlbWVudHMvZHluYW1pYy1zbGlkZXIvZHluYW1pYy1zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFRkRHluYW1pY1NlbGVjdENvbXBvbmVudCB9IGZyb20gJy4uL2R5bmFtaWMtZWxlbWVudHMvZHluYW1pYy1zZWxlY3QvZHluYW1pYy1zZWxlY3QuY29tcG9uZW50JztcbmltcG9ydCB7IFRkRHluYW1pY0RhdGVwaWNrZXJDb21wb25lbnQgfSBmcm9tICcuLi9keW5hbWljLWVsZW1lbnRzL2R5bmFtaWMtZGF0ZXBpY2tlci9keW5hbWljLWRhdGVwaWNrZXIuY29tcG9uZW50JztcblxuZXhwb3J0IGVudW0gVGREeW5hbWljVHlwZSB7XG4gIFRleHQgPSAndGV4dCcsXG4gIEJvb2xlYW4gPSAnYm9vbGVhbicsXG4gIE51bWJlciA9ICdudW1iZXInLFxuICBBcnJheSA9ICdhcnJheScsXG4gIERhdGUgPSAnZGF0ZScsXG59XG5cbmV4cG9ydCBlbnVtIFRkRHluYW1pY0VsZW1lbnQge1xuICBJbnB1dCA9ICdpbnB1dCcsXG4gIERhdGVwaWNrZXIgPSAnZGF0ZXBpY2tlcicsXG4gIFBhc3N3b3JkID0gJ3Bhc3N3b3JkJyxcbiAgVGV4dGFyZWEgPSAndGV4dGFyZWEnLFxuICBTbGlkZXIgPSAnc2xpZGVyJyxcbiAgU2xpZGVUb2dnbGUgPSAnc2xpZGUtdG9nZ2xlJyxcbiAgQ2hlY2tib3ggPSAnY2hlY2tib3gnLFxuICBTZWxlY3QgPSAnc2VsZWN0JyxcbiAgRmlsZUlucHV0ID0gJ2ZpbGUtaW5wdXQnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElUZER5bmFtaWNFbGVtZW50VmFsaWRhdG9yIHtcbiAgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGREeW5hbWljRWxlbWVudENvbmZpZyB7XG4gIGxhYmVsPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGhpbnQ/OiBzdHJpbmc7XG4gIHR5cGU6IFRkRHluYW1pY1R5cGUgfCBUZER5bmFtaWNFbGVtZW50IHwgVHlwZTxhbnk+O1xuICByZXF1aXJlZD86IGJvb2xlYW47XG4gIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgbWluPzogYW55O1xuICBtYXg/OiBhbnk7XG4gIG1pbkxlbmd0aD86IGFueTtcbiAgbWF4TGVuZ3RoPzogYW55O1xuICBzZWxlY3Rpb25zPzogc3RyaW5nW10gfCB7IHZhbHVlOiBhbnksIGxhYmVsOiBzdHJpbmcgfVtdO1xuICBtdWx0aXBsZT86IGJvb2xlYW47XG4gIGRlZmF1bHQ/OiBhbnk7XG4gIGZsZXg/OiBudW1iZXI7XG4gIHZhbGlkYXRvcnM/OiBJVGREeW5hbWljRWxlbWVudFZhbGlkYXRvcltdO1xufVxuXG5leHBvcnQgY29uc3QgRFlOQU1JQ19FTEVNRU5UX05BTUVfUkVHRVg6IFJlZ0V4cCA9IC9eW14wLTldW15cXEBdKiQvO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGREeW5hbWljRm9ybXNTZXJ2aWNlIHtcblxuICAvKipcbiAgICogTWV0aG9kIHRvIHZhbGlkYXRlIGlmIHRoZSBbbmFtZV0gaXMgYSBwcm9wZXIgZWxlbWVudCBuYW1lLlxuICAgKiBUaHJvd3MgZXJyb3IgaWYgbmFtZSBpcyBub3QgdmFsaWQuXG4gICAqL1xuICB2YWxpZGF0ZUR5bmFtaWNFbGVtZW50TmFtZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIURZTkFNSUNfRUxFTUVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHluYW1pYyBlbGVtZW50IG5hbWU6IFwiJHtuYW1lfVwiIGlzIG5vdCB2YWxpZC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWQgZGVwZW5kaW5nIG9uIFtUZER5bmFtaWNFbGVtZW50IHwgVGREeW5hbWljVHlwZV1cbiAgICogVGhyb3dzIGVycm9yIGlmIGl0IGRvZXMgbm90IGV4aXN0cyBvciBub3Qgc3VwcG9ydGVkLlxuICAgKi9cbiAgZ2V0RHluYW1pY0VsZW1lbnQoZWxlbWVudDogVGREeW5hbWljRWxlbWVudCB8IFRkRHluYW1pY1R5cGUpOiBhbnkge1xuICAgIHN3aXRjaCAoZWxlbWVudCkge1xuICAgICAgY2FzZSBUZER5bmFtaWNUeXBlLlRleHQ6XG4gICAgICBjYXNlIFRkRHluYW1pY1R5cGUuTnVtYmVyOlxuICAgICAgY2FzZSBUZER5bmFtaWNFbGVtZW50LklucHV0OlxuICAgICAgY2FzZSBUZER5bmFtaWNFbGVtZW50LlBhc3N3b3JkOlxuICAgICAgICByZXR1cm4gVGREeW5hbWljSW5wdXRDb21wb25lbnQ7XG4gICAgICBjYXNlIFRkRHluYW1pY0VsZW1lbnQuVGV4dGFyZWE6XG4gICAgICAgIHJldHVybiBUZER5bmFtaWNUZXh0YXJlYUNvbXBvbmVudDtcbiAgICAgIGNhc2UgVGREeW5hbWljVHlwZS5Cb29sZWFuOlxuICAgICAgY2FzZSBUZER5bmFtaWNFbGVtZW50LlNsaWRlVG9nZ2xlOlxuICAgICAgICByZXR1cm4gVGREeW5hbWljU2xpZGVUb2dnbGVDb21wb25lbnQ7XG4gICAgICBjYXNlIFRkRHluYW1pY0VsZW1lbnQuQ2hlY2tib3g6XG4gICAgICAgIHJldHVybiBUZER5bmFtaWNDaGVja2JveENvbXBvbmVudDtcbiAgICAgIGNhc2UgVGREeW5hbWljRWxlbWVudC5TbGlkZXI6XG4gICAgICAgIHJldHVybiBUZER5bmFtaWNTbGlkZXJDb21wb25lbnQ7XG4gICAgICBjYXNlIFRkRHluYW1pY1R5cGUuQXJyYXk6XG4gICAgICBjYXNlIFRkRHluYW1pY0VsZW1lbnQuU2VsZWN0OlxuICAgICAgICByZXR1cm4gVGREeW5hbWljU2VsZWN0Q29tcG9uZW50O1xuICAgICAgY2FzZSBUZER5bmFtaWNFbGVtZW50LkZpbGVJbnB1dDpcbiAgICAgICAgcmV0dXJuIFRkRHluYW1pY0ZpbGVJbnB1dENvbXBvbmVudDtcbiAgICAgIGNhc2UgVGREeW5hbWljRWxlbWVudC5EYXRlcGlja2VyOlxuICAgICAgY2FzZSBUZER5bmFtaWNUeXBlLkRhdGU6XG4gICAgICAgIHJldHVybiBUZER5bmFtaWNEYXRlcGlja2VyQ29tcG9uZW50O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvcjogdHlwZSAke2VsZW1lbnR9IGRvZXMgbm90IGV4aXN0IG9yIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZm9ybSBjb250cm9sIGZvciBlbGVtZW50IGRlcGVuZGluZyBbSVRkRHluYW1pY0VsZW1lbnRDb25maWddIHByb3BlcnRpZXMuXG4gICAqL1xuICBjcmVhdGVGb3JtQ29udHJvbChjb25maWc6IElUZER5bmFtaWNFbGVtZW50Q29uZmlnKTogRm9ybUNvbnRyb2wge1xuICAgIGxldCB2YWxpZGF0b3I6IFZhbGlkYXRvckZuID0gdGhpcy5jcmVhdGVWYWxpZGF0b3JzKGNvbmZpZyk7XG4gICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbCh7IHZhbHVlOiBjb25maWcuZGVmYXVsdCwgZGlzYWJsZWQ6IGNvbmZpZy5kaXNhYmxlZCB9LCB2YWxpZGF0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZm9ybSB2YWxpZGF0aW9uZGVwZW5kaW5nIFtJVGREeW5hbWljRWxlbWVudENvbmZpZ10gcHJvcGVydGllcy5cbiAgICovXG4gIGNyZWF0ZVZhbGlkYXRvcnMoY29uZmlnOiBJVGREeW5hbWljRWxlbWVudENvbmZpZyk6IFZhbGlkYXRvckZuIHtcbiAgICBsZXQgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgICBpZiAoY29uZmlnLnJlcXVpcmVkKSB7XG4gICAgICB2YWxpZGF0b3IgPSBWYWxpZGF0b3JzLnJlcXVpcmVkO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLm1heCB8fCBjb25maWcubWF4ID09PSAwKSB7XG4gICAgICB2YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW3ZhbGlkYXRvciwgVmFsaWRhdG9ycy5tYXgocGFyc2VGbG9hdChjb25maWcubWF4KSldKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5taW4gfHwgY29uZmlnLm1pbiA9PT0gMCkge1xuICAgICAgdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt2YWxpZGF0b3IsIFZhbGlkYXRvcnMubWluKHBhcnNlRmxvYXQoY29uZmlnLm1pbikpXSk7XG4gICAgfVxuICAgIGlmIChjb25maWcubWF4TGVuZ3RoIHx8IGNvbmZpZy5tYXhMZW5ndGggPT09IDApIHtcbiAgICAgIHZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbdmFsaWRhdG9yLCBWYWxpZGF0b3JzLm1heExlbmd0aChwYXJzZUZsb2F0KGNvbmZpZy5tYXhMZW5ndGgpKV0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLm1pbkxlbmd0aCB8fCBjb25maWcubWluTGVuZ3RoID09PSAwKSB7XG4gICAgICB2YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW3ZhbGlkYXRvciwgVmFsaWRhdG9ycy5taW5MZW5ndGgocGFyc2VGbG9hdChjb25maWcubWluTGVuZ3RoKSldKTtcbiAgICB9XG4gICAgLy8gQWRkIHByb3ZpZGVkIGN1c3RvbSB2YWxpZGF0b3JzIHRvIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cbiAgICBpZiAoY29uZmlnLnZhbGlkYXRvcnMpIHtcbiAgICAgIGNvbmZpZy52YWxpZGF0b3JzLmZvckVhY2goKHZhbGlkYXRvckNvbmZpZzogSVRkRHluYW1pY0VsZW1lbnRWYWxpZGF0b3IpID0+IHtcbiAgICAgICAgdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt2YWxpZGF0b3IsIHZhbGlkYXRvckNvbmZpZy52YWxpZGF0b3JdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdG9yO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEWU5BTUlDX0ZPUk1TX1BST1ZJREVSX0ZBQ1RPUlkoXG4gIHBhcmVudDogVGREeW5hbWljRm9ybXNTZXJ2aWNlKTogVGREeW5hbWljRm9ybXNTZXJ2aWNlIHtcbiAgcmV0dXJuIHBhcmVudCB8fCBuZXcgVGREeW5hbWljRm9ybXNTZXJ2aWNlKCk7XG59XG5cbmV4cG9ydCBjb25zdCBEWU5BTUlDX0ZPUk1TX1BST1ZJREVSOiBQcm92aWRlciA9IHtcbiAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIHNlcnZpY2UgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgcHJvdmlkZTogVGREeW5hbWljRm9ybXNTZXJ2aWNlLFxuICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgVGREeW5hbWljRm9ybXNTZXJ2aWNlXV0sXG4gIHVzZUZhY3Rvcnk6IERZTkFNSUNfRk9STVNfUFJPVklERVJfRkFDVE9SWSxcbn07XG4iXX0=